<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="de-DE">
    <title type="text">Syralists Blog</title>
    <subtitle type="html">Syralists persöhnlicher Blog.</subtitle>
    <updated>2020-04-03T19:59:22+02:00</updated>
    <id>https://syralist.github.io/</id>
    <link rel="alternate" type="text/html" href="https://syralist.github.io/" />
    <link rel="self" type="application/atom+xml" href="https://syralist.github.io/atom.xml" />
    <author>
            <name>Thomas Helmke</name>
            <uri>https://syralist.github.io/</uri>
            
                <email>thomas.helmke@gmx.de</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights>
    <generator uri="https://gohugo.io/" version="0.66.0">Hugo</generator>
        <entry>
            <title type="text">Umweltsensor mit ESPHome in Home Assistant</title>
            <link rel="alternate" type="text/html" href="https://syralist.github.io/posts/smarthome/esphome-sensor/" />
            <id>https://syralist.github.io/posts/smarthome/esphome-sensor/</id>
            <updated>2020-04-03T19:57:08+02:00</updated>
            <published>2020-04-03T12:53:16+02:00</published>
            <author>
                    <name>Thomas Helmke</name>
                    <uri>https://syralist.github.io/</uri>
                    <email>thomas.helmke@gmx.de</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html"><![CDATA[Umweltsensor mit ESPHome in Home Assistant In diesem Beitrag zeige ich die Schritte, um meinen Umweltsensor mit Button nachzubauen. Der Sensor misst Temperatur, Luftfeuchtigkeit und Luftdruck und hat einen Button um beliebige Aktionen auszulösen.
Vorbereitung Was ist ESPHome? Laut der Selbstbeschreibung auf esphome.]]></summary>
            
                <content type="html"><![CDATA[<h1 id="umweltsensor-mit-esphome-in-home-assistant">Umweltsensor mit ESPHome in Home Assistant</h1>
<p>In diesem Beitrag zeige ich die Schritte, um meinen Umweltsensor mit Button nachzubauen. Der Sensor misst Temperatur, Luftfeuchtigkeit und Luftdruck und hat einen Button um beliebige Aktionen auszulösen.</p>
<p><img src="/images/2020-04-03-esphome-hardware-01.jpg" alt="Fertige Box"></p>
<h2 id="vorbereitung">Vorbereitung</h2>
<h3 id="was-ist-esphome">Was ist ESPHome?</h3>
<p>Laut der Selbstbeschreibung auf <a href="https://esphome.io/" title="ESPHome">esphome.io</a> ist ESPHome ein System, um ESP8266 bzw. ESP32 Mikrocontroller mit Hilfe von einfachen Konfigurationsdateien zu programmieren.</p>
<p>ESPHome ist in Python geschrieben und lässt sich auch ohne Home Assistant einfach über <code>pip install esphome</code> oder mit <code>docker pull esphome/esphome</code> installieren. Ich benutze ESPHome als Home Assistant Addon, da bekommt man noch eine Weboberfläche zur Administration dazu.</p>
<h3 id="benötigte-hardware">Benötigte Hardware</h3>
<ul>
<li>ESP8266 Mikrocontroller - z.B. Wemos D1 mini</li>
<li>BME280 Sensor - mit I²C Breakoutboard</li>
<li>Drucktaster</li>
</ul>
<p><img src="/images/2020-04-03-esphome-hardware-02.jpg" alt="Fertige Box offen"></p>
<p>Das Gehäuse ist aus 3mm MDF gelasert. Ein Generator für solche Gehäuse ist zum Beispiel <a href="https://www.festi.info/boxes.py/" title="boxes.py">boxes.py</a>.</p>
<h3 id="sensor-und-button-anschließen">Sensor und Button anschließen</h3>
<p>Der BME280 wird per I²C angeschlossen, dafür brauchen wir die folgenden Pins:</p>
<ul>
<li>5V → VIN</li>
<li>G   → GND</li>
<li>D4 → SDA</li>
<li>D5 → SCL</li>
</ul>
<p>Den Pin für den Button kann man frei wählen, allerdings gibt es einige Pins, die spezielle Funktionen beim Booten auslösen. Ich habe hier Pin D3 verwendet, der zweite Pin des Buttons wird mit GND verbunden.</p>
<p><img src="/images/2020-04-03-esphome-hardware-04.jpg" alt="Platine von unten"></p>
<p>Ich habe das ganze mit Sockeln auf einer Lochrasterplatine aufgebaut, um die Bauteile leicht wieder auseinanderbauen zu können.</p>
<p><img src="/images/2020-04-03-esphome-hardware-03.jpg" alt="Platine von oben"></p>
<h2 id="esphome-projekt-in-home-assistant">ESPHome Projekt in Home Assistant</h2>
<h3 id="projekt-anlegen">Projekt anlegen</h3>
<p>Auf der Weboberfläche klickt man auf den freundlichen roten Button mit dem Plus, um den Wizard für neue Projekte aufzurufen.</p>
<p><img src="/images/2020-04-03-esphome-01.png" alt="ESPHome Weboberfläche"></p>
<p>Als erstes vergibt man einen Namen.</p>
<p><img src="/images/2020-04-03-esphome-02.png" alt="ESPHome Wizard Schritt 1"></p>
<p>Zweiter Schritt ist die Auswahl des Mikrocontrollers. Ich benutze für die meisten Projekte den Wemos D1 mini.</p>
<p><img src="/images/2020-04-03-esphome-03.png" alt="ESPHome Wizard Schritt 2"></p>
<p>Als letztes folgt die Angabe der WLan-Daten und des Passworts für das Over-the-air Update. Ich benutze hier die von Home Assistant bekannte <code>!secret</code> Notation. Details dazu weiter unten.</p>
<p><img src="/images/2020-04-03-esphome-04.png" alt="ESPHome Wizard Schritt 3"></p>
<p>Nun ist der Wizard abgeschlossen und zeigt uns die nächsten Schritte, um den Mikrocontroller zu programmieren.</p>
<p><img src="/images/2020-04-03-esphome-05.png" alt="ESPHome Wizard Schritt 4"></p>
<p>Nachdem man den Wizard mit <strong>Submit</strong> geschlossen hat, wird man noch auf die Schnittstellenauswahl in der oberen Ecke hingewiesen.</p>
<p><img src="/images/2020-04-03-esphome-06.png" alt="ESPHome Wizard Schritt 5"></p>
<h3 id="dateiorganisation-und-secrets">Dateiorganisation und !secrets</h3>
<p>In Home Assistant liegen die Projektdateien im Verzeichnis <code>/config/esphome</code>. Das Beispiel oben hat eine <code>umweltsensor.yaml</code> erzeugt.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">esphome</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">name</span><span class="p">:</span><span class="w"> </span>umweltsensor<span class="w">
</span><span class="w">  </span><span class="k">platform</span><span class="p">:</span><span class="w"> </span>ESP8266<span class="w">
</span><span class="w">  </span><span class="k">board</span><span class="p">:</span><span class="w"> </span>d1_mini<span class="w">
</span><span class="w"></span><span class="k">wifi</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">ssid</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;!secret wifi-ssid&#34;</span><span class="w">
</span><span class="w">  </span><span class="k">password</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;!secret wifi-password&#34;</span><span class="w">
</span><span class="w">  </span><span class="c"># Enable fallback hotspot (captive portal) in case wifi connection fails</span><span class="w">
</span><span class="w">  </span><span class="k">ap</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="k">ssid</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Umweltsensor Fallback Hotspot&#34;</span><span class="w">
</span><span class="w">    </span><span class="k">password</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;lg2kCzecpat7&#34;</span><span class="w">
</span><span class="w"></span><span class="k">captive_portal</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="c"># Enable logging</span><span class="w">
</span><span class="w"></span><span class="k">logger</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="c"># Enable Home Assistant API</span><span class="w">
</span><span class="w"></span><span class="k">api</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">password</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;!secret esphome-password&#34;</span><span class="w">
</span><span class="w"></span><span class="k">ota</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">password</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;!secret esphome-password&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Im gleichen Verzeichnis habe ich eine <code>secrets.yaml</code> angelegt. Die Einträge darin können in anderen <code>.yaml</code> Dateien mit <code>!secret</code> importiert werden. Das hat den Vorteil, dass man die Projektdatei mit anderen teilen kann, so wie ich hier, ohne dass man seine Zugangsdaten weitergibt.</p>
<p><img src="/images/2020-04-03-esphome-07.png" alt="ESPHome secrets.yaml"></p>
<h3 id="das-erste-mal-flashen">Das erste Mal Flashen</h3>
<p>Zum ersten Flashen muss der Mikrocontroller per USB mit dem Rechner verdunden werden, auf dem ESPHome läuft. In meinem Fall ist das der Raspberry Pi auf dem Home Assistant installiert ist.</p>
<p>Meistens wird der Port des Mikrocontrollers nicht sofort angezeigt, wenn man das USB Kabel anschließt. Das hängt mit dem Docker System zusammen auf dem Home Assistant basiert. Der Workaround ist das Addon neuzustarten, nachdem der Mikrocontroller angeschlossen ist.</p>
<p>Wenn nichts anderes angeschlossen ist, wird wahrscheinlich <code>/dev/ttyUSB0</code> angezeigt, in meinem Fall ist der Mikrocontroller an <code>/dev/ttyUSB1</code>.</p>
<p><img src="/images/2020-04-03-esphome-08.png" alt="ESPHome Port Auswahl"></p>
<p>Damit die Zugangsdaten korrekt importiert werden, müssen wir noch die erzeugte <code>.yaml</code> Datei bearbeiten und die Anführungszeichen bei allen Einträgen mit <code>!secret</code> entfernen. Dazu klickt man auf <strong>EDIT</strong> unter dem entsprechenden Eintrag.</p>
<p><img src="/images/2020-04-03-esphome-09.png" alt="ESPHome Edit Button"></p>
<p>Als letztes klickt man auf <strong>UPLOAD</strong> um das Flashen zu starten.</p>
<p><img src="/images/2020-04-03-esphome-10.png" alt="ESPHome Upload"></p>
<p>Wenn alles korrekt funktioniert hat, sollte nun aus der <code>.yaml</code> Datei der Arduino-Code generiert werden. Dabei werden im Hintergrund alle benötigten Bibliotheken heruntergeladen, der Code kompiliert und der Upload gestartet.</p>
<p><img src="/images/2020-04-03-esphome-11.png" alt="ESPHome Upload"></p>
<p>In der folgenden Logging-Ausgabe kann man kontrollieren, ob man die WLAN Daten korrekt eingeben hat.</p>
<p><img src="/images/2020-04-03-esphome-12.png" alt="ESPHome Upload"></p>
<p>Ab jetzt kann man den Mikrocontroller vom Raspberry Pi trennen und übers WLAN programmieren. Dafür stellt man die Schnittstelle oben auf Over-the-Air um.</p>
<h3 id="sensor-und-button-konfigurieren">Sensor und Button konfigurieren</h3>
<p>Damit der Sensor angesprochen werden kann wird als erstes die I²C Komponente geladen. Die Option <code>scan: True</code> sorgt dafür, dass bei jedem Boot der Bus nach Geräten gescannt wird.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">i2c</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">sda</span><span class="p">:</span><span class="w"> </span><span class="m">4</span><span class="w">
</span><span class="w">  </span><span class="k">scl</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">  </span><span class="k">scan</span><span class="p">:</span><span class="w"> </span>True<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Da der BME280 drei Größen misst, müssen entsprechend die drei Optionen <code>temperature</code>, <code>pressure</code> und <code>humidity</code> konfiguriert werden.</p>
<p>Unter <code>filters:</code> ist beim Temperatursensor ein statischer Offset von -7 Grad eingestellt, den ich im Vergleich mit einem zweiten Sensor ermittelt habe. Ebenso ist bei der Luftfeuchtigkeit ein statischer Offset von +10 Prozent eingestellt.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">sensor</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="k">platform</span><span class="p">:</span><span class="w"> </span>bme280<span class="w">
</span><span class="w">    </span><span class="k">temperature</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="k">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Thomas Zimmer Temperatur&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">oversampling</span><span class="p">:</span><span class="w"> </span>16x<span class="w">
</span><span class="w">      </span><span class="k">filters</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="k">offset</span><span class="p">:</span><span class="w"> </span>-<span class="m">7.0</span><span class="w">
</span><span class="w">    </span><span class="k">pressure</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="k">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Thomas Zimmer Luftdruck&#34;</span><span class="w">
</span><span class="w">    </span><span class="k">humidity</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="k">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Thomas Zimmer Feuchtigkeit&#34;</span><span class="w">
</span><span class="w">      </span><span class="k">filters</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="k">offset</span><span class="p">:</span><span class="w"> </span>+<span class="m">10.0</span><span class="w">
</span><span class="w">    </span><span class="k">address</span><span class="p">:</span><span class="w"> </span><span class="m">0x76</span><span class="w">
</span><span class="w">    </span><span class="k">update_interval</span><span class="p">:</span><span class="w"> </span>60s<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Der Button wird als Binärsensor konfiguriert. Da der Button mit GND verbunden ist, muss hier der interne Pullup-Widerstand aktiviert werden und mit <code>inverted: True</code> der Zustand invertiert werden. Damit liefert der Sensor <strong>on</strong>, wenn der Button gedrückt wird.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">binary_sensor</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="k">platform</span><span class="p">:</span><span class="w"> </span>gpio<span class="w">
</span><span class="w">    </span><span class="k">pin</span><span class="p">:</span><span class="w"> 
</span><span class="w">      </span><span class="k">number</span><span class="p">:</span><span class="w"> </span>D3<span class="w">
</span><span class="w">      </span><span class="k">mode</span><span class="p">:</span><span class="w"> </span>INPUT_PULLUP<span class="w">
</span><span class="w">      </span><span class="k">inverted</span><span class="p">:</span><span class="w"> </span>True<span class="w">
</span><span class="w">    </span><span class="k">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;Thomas Zimmer Button&#34;</span><span class="w">
</span><span class="w">    </span><span class="k">filters</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="k">delayed_on</span><span class="p">:</span><span class="w"> </span>10ms<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="mit-home-assistant-verbinden">Mit Home Assistant verbinden</h3>
<p>Nachdem das vollständige Programm auf den Mikrocontroller geladen ist, müssen die Sensoren noch in Home Assistant einbunden werden. Die Einrichtung erfolgt über die Integrationsseite in den Home Assistant Einstellungen.</p>
<p><img src="/images/2020-04-03-esphome-13.png" alt="ESPHome Integration"></p>
<p>Als Hostadresse gibt man den Namen des Projekts ein, in diesem Fall <code>umweltsensor.local</code>.</p>
<p><img src="/images/2020-04-03-esphome-14.png" alt="ESPHome Integration"></p>
<p>Nach der API Passwort Abfrage werden automatisch die Entities für die konfigurierten Sensoren zu Home Assitant hinzugefügt.</p>
<p><img src="/images/2020-04-03-esphome-15.png" alt="ESPHome Integration"></p>
]]></content>
            
            
            
                
                
                
                    
                    
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/smarthome/" term="Smarthome" label="Smarthome" />
                            
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/home-assistant/" term="Home Assistant" label="Home Assistant" />
                            
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/esphome/" term="ESPHome" label="ESPHome" />
                            
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/esp8266/" term="ESP8266" label="ESP8266" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Mein Smarthome Setup</title>
            <link rel="alternate" type="text/html" href="https://syralist.github.io/posts/smarthome/mein_setup/" />
            <id>https://syralist.github.io/posts/smarthome/mein_setup/</id>
            <updated>2020-03-22T19:07:14+01:00</updated>
            <published>2020-03-21T18:45:02+00:00</published>
            <author>
                    <name>Thomas Helmke</name>
                    <uri>https://syralist.github.io/</uri>
                    <email>thomas.helmke@gmx.de</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html"><![CDATA[Mein Smarthome Setup Hier möchte ich einen kurzen Überblick über mein Smarthome Setup geben. Auf Details werde ich dann später in weiteren Beiträgen eingehen.
Zentrale Als Smarthome-Zentrale habe ich Home Assistant auf einem Raspberry Pi 3B+ laufen. Ich benutze die native Version mit HassOS und boote direkt von einer SSD Festplatte.]]></summary>
            
                <content type="html"><![CDATA[<h1 id="mein-smarthome-setup">Mein Smarthome Setup</h1>
<p>Hier möchte ich einen kurzen Überblick über mein Smarthome Setup geben. Auf Details werde ich dann später in weiteren Beiträgen eingehen.</p>
<h2 id="zentrale">Zentrale</h2>
<p>Als Smarthome-Zentrale habe ich <a href="http://www.home-assistant.io" title="Home Assistant">Home Assistant</a> auf einem Raspberry Pi 3B+ laufen. Ich benutze die native Version mit HassOS und boote direkt von einer SSD Festplatte. Per USB angeschlossen ist hier ein Conbee Stick für die Zigbee-Anbindung. Daneben läuft ein Raspberry Pi 1 mit <a href="https://raspberrymatic.de/de/home/" title="RaspberryMatic">RaspberryMatic</a>, um meine Homematic Komponenten anzubinden.</p>
<p>Mein Router ist eine FritzBox 7590 unterstützt durch einen FritzRepeater 1750E zur Anbindung von WLAN Komponenten.</p>
<p>Sowohl die Fritzbox als auch der Haupt-Raspberry sind durch eine unterbrechungsfreie Stromversorgung gepuffert, da hier gerne mal die Sicherung fliegt, wenn ich meine Steckdosenleiste einschalte.</p>
<h3 id="hardwareliste">Hardwareliste</h3>
<ul>
<li><strong>Raspberry Pi 3B+</strong> mit 2,4A Netzteil.</li>
<li>Intenso Portable <strong>SSD mit 128GB</strong>. Zusätzliche Stromversorgung mit 2,4A Netzteil und USB Y-Kabel.</li>
<li><strong>Conbee Stick</strong> von <a href="https://phoscon.de/de/conbee" title="Conbee Stick">Dresden Elektronik</a></li>
<li>Unterbrechungsfreie Stromversorgung <strong>APC BX700U-GR</strong></li>
<li>Raspberry Pi 1 mit <strong>HM-MOD-RPI-PCB</strong> von <a href="https://de.elv.com/elv-homematic-komplettbausatz-funkmodul-fuer-raspberry-pi-hm-mod-rpi-pcb-fuer-smart-home-hausautomation-142141?fs=2908134611&amp;c=499" title="ELV Shop">ELV</a></li>
</ul>
<h3 id="software">Software</h3>
<p>Ich habe mich beim Umzug auf die SSD Festplatte gegen ein Setup mit z.B. Rasbian entschieden, sondern wieder die native Installation benutzt, weil ich so kein weiteres Betriebssystem administrieren muss, sondern alles aus der Home Assistant Oberfläche verwalten kann.
Neben dem Home Assistant laufen allerdings noch einige Addons auf dem Raspberry:</p>
<ul>
<li><strong>ADB Bridge</strong> für die Android TV Anbindung</li>
<li><strong>APC USB Daemon</strong> für die Anbindung der USV</li>
<li><strong>Duck DNS</strong> für Fernzugriff per SSL aus dem Internet</li>
<li><strong>ESPhome</strong> für selbstgebaute Komponenten</li>
<li><strong>File Editor</strong> zum Bearbeiten der Konfiguration im Browser</li>
<li><strong>Hass.io Google Drive Backup</strong> für die automatische Sicherung des Systems</li>
<li><strong>MariaDB</strong> als Alternative für die SQLite History Datenbank</li>
<li><strong>Mosquitto broker</strong> für MQTT</li>
<li><strong>Node-RED</strong> für die Automatisierung</li>
<li><strong>Samba-Share</strong> für Datenzugriff von anderen Rechnern</li>
<li><strong>TasmoAdmin</strong> für die Verwaltung der Tasmota Komponenten</li>
<li><strong>Terminal &amp; SSH</strong> für Low Level Zugriff auf das System</li>
<li><strong>chrony</strong> als lokaler NTP Server</li>
<li><strong>deCONZ</strong> für die Verwaltung der Zigbee Komponenten</li>
</ul>
<p>Zusätzlich ist natürlich auch noch <a href="https://hacs.xyz/" title="HACS">HACS</a> (Home Assistant Community Store) installiert für Custom Components, Lovelace Plugins und Themes.</p>
<h2 id="komponenten">Komponenten</h2>
<p>Der Vorteil von Home Assistant ist, dass sich Komponenten von den verschiedensten Herstellern und mit den unterschiedlichsten Technologien integrieren lassen. Dementsprechend sind in der Wohnung diverse Sensoren und Aktoren verteilt.</p>
<h3 id="sensoren">Sensoren</h3>
<p>In fast jedem Raum werden Temperatur, Luftfeuchtigkeit und Luftdruck erfasst. Dazu kommen zum einen die Aqara WSDCGQ11LM Multisensoren über Zigbee zum Einsatz, zum anderen habe ich ESP8266 mit BME280 Sensoren per ESPhome angebunden.</p>
<p>Fenster und Türen werden mit Aqara und Homematic Tür-/Fensterkontakten überwacht. Als Bewegungsmelder dient ein IKEA Tradfri über Zigbee.</p>
<p>Im Keller überwacht ein Sonoff POW die Leistungsaufnahme der Waschmaschine.</p>
<h3 id="licht">Licht</h3>
<p>Die Deckenbeleuchtung ist bisher noch nicht smart in meiner Wohnung, allerdings bleibt die sowieso meist aus, weil das Licht von Dekoleuchten oder indireker Beleuchtung kommt.</p>
<p>Die Dekoleuchten haben fast alle ein klassisches Leuchtmittel und sind in smarte Zwischensteckdosen eingesteckt. Die meisten sind von Teckin oder Sonoff und umgeflasht auf Tasmota. Eine weitere kommt von Osram und ist über Zigbee angebunden.</p>
<p>Daneben gibt es einige direkt angebundene Leuchtmittel. Eine Birne von Eufy, angebunden über deren Cloud Dienst, ein LED-Strip von Osram über Zigbee und zwei selbstgebaute LED-Leuchten, angebunden über ESPhome.</p>
<h3 id="heizung">Heizung</h3>
<p>Unsere Viessmann Heizungsanlage ist über die Cloud angebunden, an den Heizkörpern sind Homematic Thermostate montiert.</p>
<h3 id="rollladen">Rollladen</h3>
<p>Für die Steuerung der elektrischen Rollladen habe ich Shelly 2.5 Unterputzaktoren eingebaut und lokal per MQTT angebunden.</p>
<h3 id="interaktion">Interaktion</h3>
<p>Die meisten Komponenten lassen sich per Alexa Spracheingabe steuern, alle Komponenten sind über die Weboberfläche bzw. Companion App auf dem Handy steuerbar. Für einige Aktionen gibt es zusätzlich physikalische Taster. Neben dem Aqara WXKG11LM Zigbee Taster kommt auch hier wieder ein selbst gebauter Button via ESPhome zum Einsatz.</p>
<h2 id="automation">Automation</h2>
<p>Die Automationen sind natürlich das, was das Smarthome erst smart macht. Hier wieder nur eine kurze Übersicht:</p>
<p>Im Wohnzimmer wird das Licht abhängig vom Fernseher an- und ausgeschaltet. Die Heizkörper sind mit den Fenstern verknüpft und regeln zusätzlich nach Tageszeit rauf oder runter.</p>
<p>Wenn ich ins Bett gehe, wird der Rechner und das NAS heruntergefahren, die Rollladen geschlossen und der Heizkörper heruntergeregelt.</p>
<p>Es gibt Benachrichtigungen, wenn die Waschmaschine fertig ist, wenn es an der Tür klingelt und wenn der Müll rausgestellt muss.</p>
<hr>
<p>Das soll als kurzer Überblick über mein Setup genügen. Wie bereits oben geschrieben, folgen bald weitere Artikel mit Details zu einzelnen Themen.</p>
]]></content>
            
            
            
                
                
                
                    
                    
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/smarthome/" term="Smarthome" label="Smarthome" />
                            
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/home-assistant/" term="Home Assistant" label="Home Assistant" />
                            
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/zigbee/" term="Zigbee" label="Zigbee" />
                            
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/homematic/" term="Homematic" label="Homematic" />
                            
                        
                            
                            
                            
                                <category scheme="https://syralist.github.io/tags/raspberry-pi/" term="Raspberry Pi" label="Raspberry Pi" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Und jetzt bloggt er auch noch...</title>
            <link rel="alternate" type="text/html" href="https://syralist.github.io/posts/allgemein/my-first-post/" />
            <id>https://syralist.github.io/posts/allgemein/my-first-post/</id>
            <updated>2020-03-22T19:07:14+01:00</updated>
            <published>2020-03-08T18:11:30+01:00</published>
            <author>
                    <name>Thomas Helmke</name>
                    <uri>https://syralist.github.io/</uri>
                    <email>thomas.helmke@gmx.de</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html"><![CDATA[Warum ein eigener Blog? Frei nach Alf halte ich mich an das Motto: „Wenn Du sowieso nichts zu sagen hast, dann schreibt halt einen Blog.“
Ob ich wirklich nichts zu sagen habe, wird sich zeigen.
Worüber schreibe ich? Ich schreibe über Smart Home, Python und dergleichen mehr.]]></summary>
            
                <content type="html"><![CDATA[<h1 id="warum-ein-eigener-blog">Warum ein eigener Blog?</h1>
<p>Frei nach Alf halte ich mich an das Motto: „Wenn Du sowieso nichts zu sagen hast, dann schreibt halt einen Blog.“</p>
<p>Ob ich wirklich nichts zu sagen habe, wird sich zeigen.</p>
<h1 id="worüber-schreibe-ich">Worüber schreibe ich?</h1>
<p>Ich schreibe über Smart Home, Python und dergleichen mehr.</p>
]]></content>
            
            
            
                
                
                
                    
                    
                    
                
            
            
            
                
                    
                
            
        </entry>
    
</feed>
