[{"categories":["posts"],"content":"Fenster steuert Heizkörper Wie ich schon in meinem Artikel über mein Smarthomesetup geschrieben habe, sind die Automationen das, was ein Smarthome erst smart macht. Hier beschreibe ich, wie ich den Heizkörper herunterregle, wenn das Fenster geöffnet wird und wieder zurückstelle, wenn das Fenster geschlossen wird.\nBeteiligte Komponenten Das Fenster wird mit einem Xiaomi Aqara Tür-/Fensterkontakt überwacht. Der sendet den Status per Zigbee an den Conbee Stick. Der Conbee ist per Deconz in Home Assistant eingebunden.\nAm Heizkörper ist ein Homematic Heizkörperthermostat montiert. Als Homematiczentrale läuft bei mir ein Raspberry Pi mit Raspberrymatic. Die Thermostate stehen immer auf manuell, weil sie ausschließlich über Home Assistant gesteuert werden.\nDie Absenktemperatur wird über eine input_number Entity eingestellt.\nNodeRed Die Automation ist in NodeRed umgesetzt und besteht aus sechs Nodes.\nDie state node „Fenster“ reagiert auf einen Zustandswechsel des Fensterkontakts.\nDie switch node verzweigt je nach Zustand in den oberen oder unteren Weg. Der Binäre Sensor des Fensterkontakts hat den Zustand on, wenn das Fenster geöffnet ist, und off, wenn das Fenster geschlossen ist.\nWenn das Fenster geöffnet wurde, wird als erstes der aktuelle Zustand des Thermostat mit der call service node in einer temporären Szene gespeichert. Im Data Feld muss der Name der Szene und eine Liste der zu speichernden Entities übergeben werden.\n1 2 3 4 5 6  { \"scene_id\": \"thomas_snapshot\", \"snapshot_entities\": [ \"climate.0012999395e750\" ] }   Als nächstes wird der Wert der input_number Entity mit einer current state node ausgelesen.\nZuletzt wird der Thermostat mit einer call service node auf den ausgelesenen Wert gesetzt. Dafür wird im Data Feld {{payload}} als Template verwendet.\n1 2 3  { \"temperature\": {{payload}} }   Beim Schließen des Fensters wird die vorher gespeicherte Szene mit einer weiteren call service node aktiviert. Hier muss nur der Name der Szene im Data Feld übergeben werden.\n1 2 3  { \"entity_id\": \"scene.thomas_snapshot\" }   Solch einen Flow gibt es für jedes Zimmer, in dem ein smarter Thermostat montiert ist. Der Vorteil dieser Methode mit temporärer Szene liegt in der Erweiterbarkeit. Wenn weitere Entities berücksichtigt werden sollen, müssen sie nur an einer Stelle hinzugefügt werden.\nHier noch der komplette Flow zum importieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180  [ { \"id\": \"d302a18c.b4a5c\", \"type\": \"api-call-service\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Temperatur speichern\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"debugenabled\": false, \"service_domain\": \"scene\", \"service\": \"create\", \"entityId\": \"\", \"data\": \"{\\\"scene_id\\\":\\\"thomas_snapshot\\\",\\\"snapshot_entities\\\":[\\\"climate.0012999395e750\\\"]}\", \"dataType\": \"json\", \"mergecontext\": \"\", \"output_location\": \"\", \"output_location_type\": \"none\", \"mustacheAltTags\": false, \"x\": 620, \"y\": 1040, \"wires\": [ [ \"2ba89685.0924aa\" ] ] }, { \"id\": \"68ffd494.662f3c\", \"type\": \"server-state-changed\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Fenster\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"exposeToHomeAssistant\": false, \"haConfig\": [ { \"property\": \"name\", \"value\": \"\" }, { \"property\": \"icon\", \"value\": \"\" } ], \"entityidfilter\": \"binary_sensor.tur_thomas\", \"entityidfiltertype\": \"exact\", \"outputinitially\": false, \"state_type\": \"str\", \"haltifstate\": \"\", \"halt_if_type\": \"str\", \"halt_if_compare\": \"is\", \"outputs\": 1, \"output_only_on_state_change\": true, \"x\": 100, \"y\": 1060, \"wires\": [ [ \"8c0ea6fb.5a5d08\" ] ] }, { \"id\": \"8c0ea6fb.5a5d08\", \"type\": \"switch\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"\", \"property\": \"payload\", \"propertyType\": \"msg\", \"rules\": [ { \"t\": \"eq\", \"v\": \"on\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"off\", \"vt\": \"str\" } ], \"checkall\": \"true\", \"repair\": false, \"outputs\": 2, \"x\": 310, \"y\": 1060, \"wires\": [ [ \"d302a18c.b4a5c\" ], [ \"e5f92e8f.b86af\" ] ] }, { \"id\": \"4acbf5b0.7c7bbc\", \"type\": \"api-call-service\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Temperatur setzen\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"debugenabled\": false, \"service_domain\": \"climate\", \"service\": \"set_temperature\", \"entityId\": \"climate.0012999395e750\", \"data\": \"{\\\"temperature\\\": {{payload}}}\", \"dataType\": \"json\", \"mergecontext\": \"\", \"output_location\": \"\", \"output_location_type\": \"none\", \"mustacheAltTags\": false, \"x\": 1050, \"y\": 1040, \"wires\": [ [] ] }, { \"id\": \"e5f92e8f.b86af\", \"type\": \"api-call-service\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Temperatur zurücksetzen\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"debugenabled\": false, \"service_domain\": \"scene\", \"service\": \"turn_on\", \"entityId\": \"scene.thomas_snapshot\", \"data\": \"{\\\"entity_id\\\":\\\"scene.thomas_snapshot\\\"}\", \"dataType\": \"json\", \"mergecontext\": \"\", \"output_location\": \"\", \"output_location_type\": \"none\", \"mustacheAltTags\": false, \"x\": 630, \"y\": 1100, \"wires\": [ [] ] }, { \"id\": \"2ba89685.0924aa\", \"type\": \"api-current-state\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"temp_low\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"outputs\": 1, \"halt_if\": \"\", \"halt_if_type\": \"str\", \"halt_if_compare\": \"is\", \"override_topic\": false, \"entity_id\": \"input_number.temperatur_niedrig\", \"state_type\": \"num\", \"state_location\": \"payload\", \"override_payload\": \"msg\", \"entity_location\": \"data\", \"override_data\": \"msg\", \"blockInputOverrides\": false, \"x\": 840, \"y\": 1040, \"wires\": [ [ \"4acbf5b0.7c7bbc\" ] ] }, { \"id\": \"db71ae1a.4969e\", \"type\": \"server\", \"z\": \"\", \"name\": \"Home Assistant\", \"legacy\": false, \"addon\": true, \"rejectUnauthorizedCerts\": true, \"ha_boolean\": \"y|yes|true|on|home|open\", \"connectionDelay\": true, \"cacheJson\": true } ]   ","description":"","tags":["Smarthome","NodeRed","HomeAssistant","Zigbee","Xiaomi","Homematic"],"title":"Fensterautomation","uri":"/posts/smarthome/fensterautomation/"},{"categories":["posts"],"content":"In diesem Beitrag zeige ich, wie ich eine Liste mit Terminen einlese, verarbeite und dann im ICS Format abspeichere.\nHintergrund Die Bremer Stadtreinigung bietet die Müllabfuhrtermine zum Download als ICS Datei und als CSV Datei an. Leider sind dabei für Restmüll und Biomüll jeweils zwei einzelne Termine eingetragen obwohl beides am gleichen Tag abgeholt wird.\nDa ich die Termine ausserdem in mein Smarthome einbinde, um darüber Benachrichtungen zu erhalten, möchte ich sie ausserdem im einem bestimmten Format im Kalender stehen haben. Details zur Einbindung folgen in einem späteren Artikel.\nDas Python-Skript Zu finden ist das fertige Skript hier auf Github. Man braucht mindestens Python 3.6, da ich f-Strings verwende.\nImports Zuerst werden die benötigte Module importiert. ics und arrow können über pip installiert werden, die anderen Module sind in der Standardlibrary enthalten.\n1 2 3 4 5  import csv from ics import Calendar, Event import arrow from dateutil import tz import datetime    csv : Lesen und Schreiben von CSV Dateien ics : Lesen und Schreiben von ICS Dateien arrow : erweiterte Funktionen für Zeitobjekte dateutil.tz : Zeitzonen-Definitionen datetime : Standardfunktionen für Zeitobjekte  Einstellungen Damit mein Skript auch für andere interessant ist, habe ich versucht, verschiedene Möglichkeiten die Termine zu erstellen zu programmieren und parametrierbar zu machen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  ###### Einstellungen ###### # CSV-Datei von der Eno csv_file = r\"Abfuhrtermine für Auf dem Kamp.csv\" # Soll die Art der Abfuhr in den Titel eingetragen werden? True/False descriptive_title = True # Soll für die HomeAssistant Integration ein Offset eingetragen werden? 0..23 offset_hours = 6 # Soll ein ganztägiger Termin erzeugt werden? True/False all_day = True # Workaround für fehlerhafte All Day Events in ics.py aktivieren? True/False ics_workaround = True # Soll der Termin am Tag vor der Abfuhr erzeugt werden? True/False on_day_before = False # Zu welcher Stunde der Termin erzeugt werden, wenn er nicht ganztägig ist? 0..23 event_hour = 18 # Wie lange soll der Termin sein, wenn er nicht ganztägig ist? 0..23 duration_hour = 1 ######   Eingestellt werden kann, ob der Termin ganztägig oder zu einer bestimmten Stunde mit einer einstellbaren Dauer erzeugt werden soll. Dabei kann man den Termin am Vortag der Abfuhr erzeugen oder am richtigen Tag. Man kann die Art der Abfuhr mit in den Titel schreiben lassen oder nur „Müllabfuhr“. Für die Einbindung in Home Assistant kann man einen Offset eintragen lassen.\nHilfsvariablen Bevor es an das Einlesen der CSV Datei geht, erzeuge ich einige Hilfsvariablen.\n1 2 3 4 5 6  # Hilfsvariablen offset_string = f\" !!-{offset_hours:02d}:00\" # globale Variablen vorbelegen d = {} c = Calendar()   Der offset_string wird für die schon angesprochene Home Assistant Einbindung benötigt. Ich benutze hier einen f-String, um den Inhalt der Variablen in den String einzufügen. Der Ausdruck offset_hours:02d sorgt dafür, dass einstellige Zahlen mit führender Null eingefügt werden.\nFür den folgenden Code brauche ich dann noch ein leeres Dictionary d und ein leeres Calendar-Objekt c.\nCSV Datei einlesen Die Einträge in der CSV-Datei sehen folgendermaßen aus:\n1 2 3 4  \"Wochentag\";\"Datum\";\"Abfuhrart\" \"Samstag\";\"04.01.2020\";\"Papier / Gelber Sack\" \"Mittwoch\";\"08.01.2020\";\"Bioabfall\" \"Mittwoch\";\"08.01.2020\";\"Restmüll\"   Die CSV-Datei wird zeilenweise eingelesen und die Einträge vorverarbeitet.\n1 2 3 4 5 6 7 8 9 10 11 12 13  ## Datei öffnen with open(csv_file) as f: # CSV parsen csv_reader = csv.reader(f, delimiter=';', quotechar='\"') for row in csv_reader: if row[0] == 'Wochentag': # Überschrift überspringen continue # Mehrere Abfuhren an einem Tag zusammenfassen if row[1] in d: d[row[1]] =f\"{d[row[1]]} / {row[2]}\" else: d[row[1]] = row[2]   Dem csv.reader muss man dabei das Trennzeichen und den Quotechar mitgeben, damit die Datei korrekt eingelesen wird.\nIn der for-Schleife wird zuerst die Überschrift übersprungen. Als nächstes wird mit if row[1] in d geprüft, ob das Datum schon in meinem Dictionary eingetragen ist. Wenn das der Fall ist, werden die beiden Abfuhrarten über einen f-String zusammengefasst und der Eintrag im Dictionary aktualisiert. Ansonsten wird einfach ein neuer Eintrag zum Dictionary hinzugefügt.\nDamit habe ich nun ein Dictionary mit dem Datums-String als key und der Abfuhrart als value.\nEvents anlegen Im nächsten Schritt wird jetzt über das Dictionary iteriert und das oben angelegte Calendar-Objekt mit Events befüllt. d.items() gibt dabei jeweils Key und Value als Tuple zurück.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Zusammengefasste Termine ins ICS Format umandeln for datum, abfuhr in d.items(): # Event anlegen e = Event() # Titel zusammenbauen e.name = f\"Müllabfuhr{(' ' + abfuhr) if descriptive_title else ''}{offset_string if offset_hours \u003e 0 else ''}\" # Startzeitpunkt zusammenbauen _date = datetime.datetime.strptime(datum, \"%d.%m.%Y\").replace(hour=event_hour, tzinfo=tz.gettz(\"Europe/Berlin\")) begin = arrow.get(_date) if ics_workaround: begin = begin.shift(days = 1) e.begin = begin.shift(days = -1 if on_day_before else 0) # Dauer eintragen bzw. ganztägigen Termin erzeugen e.duration = {\"hours\": duration_hour} if all_day: e.make_all_day() # Art der Abfuhr eintragen e.description = abfuhr # Event eintragen c.events.add(e)   Für den Titel des Events benutze ich wieder einen f-String, um mehrere Strings zusammenzusetzen. Der Ausdruck (' ' + abfuhr) if descriptive_title else '' ist ein sogennater ternärer Operator. Wenn descriptive_title auf True gesetzt ist, wird der Teil vor dem if benutzt, ansonsten der Teil hinter dem else.\nDer Startzeitpunkt wird zunächst als datetime Objekt mit strptime aus dem Key gelesen. Gleichzeitig wird mit .replace die Stunde auf den oben definierten Wert gesetzt und die Zeitzone eingestellt. Das datetime Objekt wird anschließend in arrow Objekt umgewandelt, weil das vom ICS Modul erwartet wird.\nDas ICS Modul hat in der verwendeten Version den Bug, dass bei ganztägigen Terminen die Zeitzone nicht berücksichtigt wird und so der Termin einen Tag zu früh erscheint. Als Workaround schiebe ich daher den Termin mit .shift einen Tag nach vorne, so dass er von ICS am richtigen Tag erzeugt wird. Wenn oben konfiguriert ist, dass der Termin am Tag vor der Abfuhr erzeugt werden soll, wird mit dem gleichen Befehl der Zeitpunkt wieder nach hinten geschoben.\nNun wird die oben eingestellte Dauer in den Termin eingetragen und anschließend gegebenenfalls der Termin in einen ganztägigen Termin umgewandelt.\nZu guter Letzt wird die Abfuhrart in die Terminbeschreibung eingetragen und das Event zum Calender Objekt hinzugefügt.\nICS Datei schreiben Der letzte Schritt ist dann das Calendar Objekt in eine Datei zu schreiben.\n1 2 3  # Kalenderdatei schreiben with open(\"abfuhr.ics\", \"w\") as f: f.writelines(c)   Die entstandene Datei kann man nun zum Beispiel in Google importieren.\n","description":"","tags":["Python","Home Assistant","Datatransformation","ICS"],"title":"Termine mit Python aufbereiten","uri":"/posts/programmieren/termine_aufbereiten/"},{"categories":["posts"],"content":"Dieser Blog wird mit Hugo erstellt. In diesem Beitrag erzähle ich was es damit auf sich hat und wie ich dazu gekommen bin.\nWas ist Hugo? Hugo ist nach eigener Aussage das weltweit schnellste Framework für die Erstellung statischer Webseiten. Hugo ist in Go programmiert und verfügbar für alle gängigen Betriebssysteme.\nDie Beiträge werden in Markdown geschrieben und dann „kompiliert“ um die HTML Seiten zu erstellen. Das Aussehen wird dabei über Themes festgelegt.\nDamit ist der Workflow mit dem von $\\LaTeX$ vergleichbar.\nWarum Hugo? An den meisten Content-Management-Systemen wie Wordpress, Drupal, Typo3, etc. hat mich immer gestört, dass man dafür ein mehr oder weniger mächtiges Backend aufsetzen muss. Man braucht immer PHP oder Python und eine Datenbank, auch wenn man eigentlich nur einen einfachen Blog schreiben möchte.\nIm Self Hosted Podcast habe ich dann von Hugo gehört.\nWie geht es los? Vorbereitung Für Hugo gibt es diverse Installationsmethoden. Auf meinem Windowsrechner habe ich das Programm als ZIP heruntergeladen, unter Linux habe ich es mit Snap installiert. Details sind auf der Hugo Webseite zu finden.\nEs ist nicht zwingend erforderlich, aber es erleichtert einige Vorgänge, wenn man Git benutzt. Daher gehe ich in diesem Artikel davon aus, dass ihr Git installiert habt und über einen Github Account verfügt.\nSeite anlegen Das Grundgerüst der Seite legt man mit dem folgenden Kommando auf der Konsole an:\nhugo new site meinblog Hugo erzeugt damit ein Unterverzeichnis mit dem Namen meinblog und diesem Inhalt:\narchetypes/ config.toml content/ data/ layouts/ static/ themes/ Als nächstes sollte man sich ein Theme aus der Hugo Theme Liste aussuchen. Ich habe einige ausprobiert und mich schließlich für das MemE Theme entschieden. Die Installation funktioniert am einfachsten mit Git wie im README beschrieben. Die config.toml muss man an seine eigenen Bedürfnisse anpassen. Dazu folgt noch ein weiterer Artikel.\nArtikel anlegen Artikel legt man im Verzeichnis content als .md-Dateien an. Dabei kann man optional Unterordner als Kategorien anlegen. Man kann die Datei manuell anlegen oder diesen Hugo-Befehl dafür benutzen:\nhugo new posts/my-first-post.md Der Vorteil gegenüber dem manuellen Anlegen ist, dass gleich ein Frontmatter mit angelegt wird. Das ist der Konfigurationsbereich des Artikels, wo Aussehen und Verhalten angepasst werden kann. Auch dazu folgt noch ein weiterer Artikel.\nIn diesem Zustand kann man jetzt schon den integrierten Server starten und die (leere) Seite anzeigen:\nhugo server -D Die Option -D an dieser Stelle ist wichtig, damit auch Artikel die als Draft (also Entwurf) gekennzeichnet sind erzeugt und angezeigt werden.\nJetzt kann man seine Artikel schreiben. Wenn der Server im Hintergrund läuft, wird die Seite automatisch neu erzeugt und im Browser aktualisiert, sobald man eine Datei ändert und speichert.\nSeite veröffentlichen Wenn man fertig mit seinen Artikeln ist ruft man hugo ohne weitere Optionen auf. Damit wird im Unterverzeichnis public die fertige Webseite mit allen nötigen Dateien erzeugt. Dieses Verzeichnis kann jetzt auf jedem Webserver gehostet werden. Der Workflow für das Hosten als github.io Seite wird auf der Hugo-Webseite gezeigt.\n","description":"","tags":["Hugo","Website"],"title":"Website mit Hugo erstellen -- Einstieg","uri":"/posts/allgemein/website-mit-hugo/"},{"categories":["posts"],"content":"In diesem Beitrag zeige ich die Schritte, um meinen Umweltsensor mit Button nachzubauen. Der Sensor misst Temperatur, Luftfeuchtigkeit und Luftdruck und hat einen Button um beliebige Aktionen auszulösen.\nVorbereitung Was ist ESPHome? Laut der Selbstbeschreibung auf esphome.io ist ESPHome ein System, um ESP8266 bzw. ESP32 Mikrocontroller mit Hilfe von einfachen Konfigurationsdateien zu programmieren.\nESPHome ist in Python geschrieben und lässt sich auch ohne Home Assistant einfach über pip install esphome oder mit docker pull esphome/esphome installieren. Ich benutze ESPHome als Home Assistant Addon, da bekommt man noch eine Weboberfläche zur Administration dazu.\nBenötigte Hardware  ESP8266 Mikrocontroller - z.B. Wemos D1 mini BME280 Sensor - mit I²C Breakoutboard Drucktaster  Das Gehäuse ist aus 3mm MDF gelasert. Ein Generator für solche Gehäuse ist zum Beispiel boxes.py.\nSensor und Button anschließen Der BME280 wird per I²C angeschlossen, dafür brauchen wir die folgenden Pins:\n 5V → VIN G → GND D4 → SDA D5 → SCL  Den Pin für den Button kann man frei wählen, allerdings gibt es einige Pins, die spezielle Funktionen beim Booten auslösen. Ich habe hier Pin D3 verwendet, der zweite Pin des Buttons wird mit GND verbunden.\nIch habe das ganze mit Sockeln auf einer Lochrasterplatine aufgebaut, um die Bauteile leicht wieder auseinanderbauen zu können.\nESPHome Projekt in Home Assistant Projekt anlegen Auf der Weboberfläche klickt man auf den freundlichen roten Button mit dem Plus, um den Wizard für neue Projekte aufzurufen.\nAls erstes vergibt man einen Namen.\nZweiter Schritt ist die Auswahl des Mikrocontrollers. Ich benutze für die meisten Projekte den Wemos D1 mini.\nAls letztes folgt die Angabe der WLan-Daten und des Passworts für das Over-the-air Update. Ich benutze hier die von Home Assistant bekannte !secret Notation. Details dazu weiter unten.\nNun ist der Wizard abgeschlossen und zeigt uns die nächsten Schritte, um den Mikrocontroller zu programmieren.\nNachdem man den Wizard mit Submit geschlossen hat, wird man noch auf die Schnittstellenauswahl in der oberen Ecke hingewiesen.\nDateiorganisation und !secrets In Home Assistant liegen die Projektdateien im Verzeichnis /config/esphome. Das Beispiel oben hat eine umweltsensor.yaml erzeugt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  esphome:name:umweltsensorplatform:ESP8266board:d1_miniwifi:ssid:\"!secret wifi-ssid\"password:\"!secret wifi-password\"# Enable fallback hotspot (captive portal) in case wifi connection failsap:ssid:\"Umweltsensor Fallback Hotspot\"password:\"lg2kCzecpat7\"captive_portal:# Enable logginglogger:# Enable Home Assistant APIapi:password:\"!secret esphome-password\"ota:password:\"!secret esphome-password\"  Im gleichen Verzeichnis habe ich eine secrets.yaml angelegt. Die Einträge darin können in anderen .yaml Dateien mit !secret importiert werden. Das hat den Vorteil, dass man die Projektdatei mit anderen teilen kann, so wie ich hier, ohne dass man seine Zugangsdaten weitergibt.\nDas erste Mal Flashen Zum ersten Flashen muss der Mikrocontroller per USB mit dem Rechner verdunden werden, auf dem ESPHome läuft. In meinem Fall ist das der Raspberry Pi auf dem Home Assistant installiert ist.\nMeistens wird der Port des Mikrocontrollers nicht sofort angezeigt, wenn man das USB Kabel anschließt. Das hängt mit dem Docker System zusammen auf dem Home Assistant basiert. Der Workaround ist das Addon neuzustarten, nachdem der Mikrocontroller angeschlossen ist.\nWenn nichts anderes angeschlossen ist, wird wahrscheinlich /dev/ttyUSB0 angezeigt, in meinem Fall ist der Mikrocontroller an /dev/ttyUSB1.\nDamit die Zugangsdaten korrekt importiert werden, müssen wir noch die erzeugte .yaml Datei bearbeiten und die Anführungszeichen bei allen Einträgen mit !secret entfernen. Dazu klickt man auf EDIT unter dem entsprechenden Eintrag.\nAls letztes klickt man auf UPLOAD um das Flashen zu starten.\nWenn alles korrekt funktioniert hat, sollte nun aus der .yaml Datei der Arduino-Code generiert werden. Dabei werden im Hintergrund alle benötigten Bibliotheken heruntergeladen, der Code kompiliert und der Upload gestartet.\nIn der folgenden Logging-Ausgabe kann man kontrollieren, ob man die WLAN Daten korrekt eingeben hat.\nAb jetzt kann man den Mikrocontroller vom Raspberry Pi trennen und übers WLAN programmieren. Dafür stellt man die Schnittstelle oben auf Over-the-Air um.\nSensor und Button konfigurieren Damit der Sensor angesprochen werden kann wird als erstes die I²C Komponente geladen. Die Option scan: True sorgt dafür, dass bei jedem Boot der Bus nach Geräten gescannt wird.\n1 2 3 4  i2c:sda:4scl:5scan:True  Da der BME280 drei Größen misst, müssen entsprechend die drei Optionen temperature, pressure und humidity konfiguriert werden.\nUnter filters: ist beim Temperatursensor ein statischer Offset von -7 Grad eingestellt, den ich im Vergleich mit einem zweiten Sensor ermittelt habe. Ebenso ist bei der Luftfeuchtigkeit ein statischer Offset von +10 Prozent eingestellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  sensor:- platform:bme280temperature:name:\"Thomas Zimmer Temperatur\"oversampling:16xfilters:- offset:-7.0pressure:name:\"Thomas Zimmer Luftdruck\"humidity:name:\"Thomas Zimmer Feuchtigkeit\"filters:- offset:+10.0address:0x76update_interval:60s  Der Button wird als Binärsensor konfiguriert. Da der Button mit GND verbunden ist, muss hier der interne Pullup-Widerstand aktiviert werden und mit inverted: True der Zustand invertiert werden. Damit liefert der Sensor on, wenn der Button gedrückt wird.\n1 2 3 4 5 6 7 8 9  binary_sensor:- platform:gpiopin:number:D3mode:INPUT_PULLUPinverted:Truename:\"Thomas Zimmer Button\"filters:- delayed_on:10ms  Mit Home Assistant verbinden Nachdem das vollständige Programm auf den Mikrocontroller geladen ist, müssen die Sensoren noch in Home Assistant einbunden werden. Die Einrichtung erfolgt über die Integrationsseite in den Home Assistant Einstellungen.\nAls Hostadresse gibt man den Namen des Projekts ein, in diesem Fall umweltsensor.local.\nNach der API Passwort Abfrage werden automatisch die Entities für die konfigurierten Sensoren zu Home Assitant hinzugefügt.\n","description":"","tags":["Smarthome","Home Assistant","ESPHome","ESP8266"],"title":"Umweltsensor mit ESPHome in Home Assistant","uri":"/posts/smarthome/esphome-sensor/"},{"categories":["posts"],"content":"Hier möchte ich einen kurzen Überblick über mein Smarthome Setup geben. Auf Details werde ich dann später in weiteren Beiträgen eingehen.\nZentrale Als Smarthome-Zentrale habe ich Home Assistant auf einem Raspberry Pi 3B+ laufen. Ich benutze die native Version mit HassOS und boote direkt von einer SSD Festplatte. Per USB angeschlossen ist hier ein Conbee Stick für die Zigbee-Anbindung. Daneben läuft ein Raspberry Pi 1 mit RaspberryMatic, um meine Homematic Komponenten anzubinden.\nMein Router ist eine FritzBox 7590 unterstützt durch einen FritzRepeater 1750E zur Anbindung von WLAN Komponenten.\nSowohl die Fritzbox als auch der Haupt-Raspberry sind durch eine unterbrechungsfreie Stromversorgung gepuffert, da hier gerne mal die Sicherung fliegt, wenn ich meine Steckdosenleiste einschalte.\nHardwareliste  Raspberry Pi 3B+ mit 2,4A Netzteil. Intenso Portable SSD mit 128GB. Zusätzliche Stromversorgung mit 2,4A Netzteil und USB Y-Kabel. Conbee Stick von Dresden Elektronik Unterbrechungsfreie Stromversorgung APC BX700U-GR Raspberry Pi 1 mit HM-MOD-RPI-PCB von ELV  Software Ich habe mich beim Umzug auf die SSD Festplatte gegen ein Setup mit z.B. Rasbian entschieden, sondern wieder die native Installation benutzt, weil ich so kein weiteres Betriebssystem administrieren muss, sondern alles aus der Home Assistant Oberfläche verwalten kann. Neben dem Home Assistant laufen allerdings noch einige Addons auf dem Raspberry:\n ADB Bridge für die Android TV Anbindung APC USB Daemon für die Anbindung der USV Duck DNS für Fernzugriff per SSL aus dem Internet ESPhome für selbstgebaute Komponenten File Editor zum Bearbeiten der Konfiguration im Browser Hass.io Google Drive Backup für die automatische Sicherung des Systems MariaDB als Alternative für die SQLite History Datenbank Mosquitto broker für MQTT Node-RED für die Automatisierung Samba-Share für Datenzugriff von anderen Rechnern TasmoAdmin für die Verwaltung der Tasmota Komponenten Terminal \u0026 SSH für Low Level Zugriff auf das System chrony als lokaler NTP Server deCONZ für die Verwaltung der Zigbee Komponenten  Zusätzlich ist natürlich auch noch HACS (Home Assistant Community Store) installiert für Custom Components, Lovelace Plugins und Themes.\nKomponenten Der Vorteil von Home Assistant ist, dass sich Komponenten von den verschiedensten Herstellern und mit den unterschiedlichsten Technologien integrieren lassen. Dementsprechend sind in der Wohnung diverse Sensoren und Aktoren verteilt.\nSensoren In fast jedem Raum werden Temperatur, Luftfeuchtigkeit und Luftdruck erfasst. Dazu kommen zum einen die Aqara WSDCGQ11LM Multisensoren über Zigbee zum Einsatz, zum anderen habe ich ESP8266 mit BME280 Sensoren per ESPhome angebunden.\nFenster und Türen werden mit Aqara und Homematic Tür-/Fensterkontakten überwacht. Als Bewegungsmelder dient ein IKEA Tradfri über Zigbee.\nIm Keller überwacht ein Sonoff POW die Leistungsaufnahme der Waschmaschine.\nLicht Die Deckenbeleuchtung ist bisher noch nicht smart in meiner Wohnung, allerdings bleibt die sowieso meist aus, weil das Licht von Dekoleuchten oder indireker Beleuchtung kommt.\nDie Dekoleuchten haben fast alle ein klassisches Leuchtmittel und sind in smarte Zwischensteckdosen eingesteckt. Die meisten sind von Teckin oder Sonoff und umgeflasht auf Tasmota. Eine weitere kommt von Osram und ist über Zigbee angebunden.\nDaneben gibt es einige direkt angebundene Leuchtmittel. Eine Birne von Eufy, angebunden über deren Cloud Dienst, ein LED-Strip von Osram über Zigbee und zwei selbstgebaute LED-Leuchten, angebunden über ESPhome.\nHeizung Unsere Viessmann Heizungsanlage ist über die Cloud angebunden, an den Heizkörpern sind Homematic Thermostate montiert.\nRollladen Für die Steuerung der elektrischen Rollladen habe ich Shelly 2.5 Unterputzaktoren eingebaut und lokal per MQTT angebunden.\nInteraktion Die meisten Komponenten lassen sich per Alexa Spracheingabe steuern, alle Komponenten sind über die Weboberfläche bzw. Companion App auf dem Handy steuerbar. Für einige Aktionen gibt es zusätzlich physikalische Taster. Neben dem Aqara WXKG11LM Zigbee Taster kommt auch hier wieder ein selbst gebauter Button via ESPhome zum Einsatz.\nAutomation Die Automationen sind natürlich das, was das Smarthome erst smart macht. Hier wieder nur eine kurze Übersicht:\nIm Wohnzimmer wird das Licht abhängig vom Fernseher an- und ausgeschaltet. Die Heizkörper sind mit den Fenstern verknüpft und regeln zusätzlich nach Tageszeit rauf oder runter.\nWenn ich ins Bett gehe, wird der Rechner und das NAS heruntergefahren, die Rollladen geschlossen und der Heizkörper heruntergeregelt.\nEs gibt Benachrichtigungen, wenn die Waschmaschine fertig ist, wenn es an der Tür klingelt und wenn der Müll rausgestellt muss.\n Das soll als kurzer Überblick über mein Setup genügen. Wie bereits oben geschrieben, folgen bald weitere Artikel mit Details zu einzelnen Themen.\n","description":"","tags":["Smarthome","Home Assistant","Zigbee","Homematic","Raspberry Pi"],"title":"Mein Smarthome Setup","uri":"/posts/smarthome/mein_setup/"},{"categories":["posts"],"content":"Warum ein eigener Blog? Frei nach Alf halte ich mich an das Motto: „Wenn Du sowieso nichts zu sagen hast, dann schreibt halt einen Blog.“\nOb ich wirklich nichts zu sagen habe, wird sich zeigen.\nWorüber schreibe ich? Ich schreibe über Smart Home, Python und dergleichen mehr.\n","description":"","tags":null,"title":"Und jetzt bloggt er auch noch...","uri":"/posts/allgemein/my-first-post/"}]
