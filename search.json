[{"categories":["posts"],"content":"Normale Klingel kann jeder Bei einer klassischen Türklingel wird durch das Drücken des Klingelknopfs ein Stromkreis geschlossen und dadurch eine Glocke oder ähnliches betätigt. Für die Einbindung solcher Klingeln gibt es reichlich Anleitungen und mehr oder weniger fertige Lösungen zur Einbindung in Smarthome Systeme.\nBei Mehrfamilienhäusern gibt es allerdings häufig Klingelanlagen, die etwas komplizierter aufgebaut sind mit Gegensprechanlage, Türsummer, Lichtsteuerung, etc.\nTCS Klingelanlagen Bei mir im Haus ist eine solche Anlage von TCS eingebaut. Hier hängen alle Wohnungseinheiten parallel an einem proprietären Bus und reagieren auf direkt adressierte Nachrichten.\nDie Klingelanlage verstehen Der erste Schritt ist, die elektrische Seite zu verstehen. Wenn man die Wohnungseinheit der Klingel von der Wand nimmt, findet man nur zwei Drähte. Mit dem Multimeter misst man hier 24V, die sich etwas reduzieren, wenn die Klingel betätigt wird. Aus den wenigen Quellen im Internet zu dem TCS System erfährt man, dass die 24V für ein bis zwei Millisekunden auf 0V gezogen werden, um damit Nullen und Einsen eines binären Protokolls zu codieren. Bei Aaron Christophel gibt es ein Video, in dem er mit einem Oszilloskop das Protkoll reverse-engineered.\nDie Kurzversion ist, dass jedes angeschlossene Gerät eine eindeutige Adresse hat und die verschiedenen Aktionen wie Klingeln, Türsummer oder Licht einschalten als Nachrichten auf den Bus geschickt werden. Die Nachrichten sind entweder vier oder acht Byte lang und werden von einem Mikrocontroller in der Wohnungseinheit ausgewertet.\nDen Bus mithören Da es sich bei dem Bus um ein Spannungssignal handelt, können wir uns einfach parallel mit an den Bus hängen und die Nachrichten so mithören. Um den Bus mithören zu können, müssen die 24V auf 3.3V reduziert werden, die ein ESP8266 verarbeiten kann. In diesem Fall reicht dafür ein einfacher Spannungsteiler aus 1MΩ und 147kΩ. In meiner ersten Variante hatte ich die Spannungshöhe über den analogen Eingang eingelesen und direkt im loop() ausgewertet. Dabei war das Problem, dass der Jitter zu groß war, also die Länge der Impulse nicht zuverlässig erkannt wurde. Dadurch wurde öfter mal das Klingeln nicht erkannt.\nIn der aktuellen Version lese ich die Spannung als digitalen Eingang ein und benutze den Code von Aaron, in dem die Flankenwechsel eine Interrupt-Funktion aufrufen in der die Nachrichten dekodiert werden.\nDer fertige Code ist wie immer in meinem Github Repository zu finden.\nAnbindung an Home Assistant MQTT Disovery Die ursprüngliche Idee war, die Anbindung an Home Assistant per ESPHome zu realisieren. Leider funktioniert damit der Interrupt nicht, also ist die Lösung jetzt eine direkte MQTT Anbindung.\nDie Konfiguration in Home Assistant läuft über MQTT Discovery. Dafür wird eine JSON Payload an das Topic homeassistant/device_automation/klingel_sensor/config geschickt. Wichtig ist, das Retain-Flag zu setzen, sonst vergisst Home Assistant die Konfiguration beim Neustart.\n1 2 3 4 5 6 7 8 9 10 11 12 13  { \"automation_type\": \"trigger\", \"payload\": \"0e22e280\", \"topic\": \"home/flur/klingel\", \"type\": \"button_short_press\", \"subtype\": \"button_1\", \"device\": { \"name\": \"Klingel Sensor\", \"identifiers\": \"esp8266-14c4ed\", \"manufacturer\": \"Syralist\", \"model\": \"tcs-interrupt\" } }   Die Payload in dem JSON entspricht der Nachricht, die vom Bus gelesen wird, wenn die eigene Klingel gedrückt wird. Um die passende Nachricht zu finden, verbindet man sich einfach mit dem MQTT Broker und guckt, was auf dem konfigurierten Topic gesendet wird, wenn die Klingel gedrückt wird.\nMit dieser Konfiguration hat man im Home Assistant ein Gerät angelegt ohne Entities aber mit einem MQTT Device Trigger, den man als Auslöser für Automationen verwenden kann. Automationen Ich habe zwei Automationen mit der Klingel verknüpft. Zum einen bekomme ich eine Benachrichtigung auf meinem Handy über die Home Assistant App. Zum anderen lasse ich eine LED Leiste grün blinken, allerdings nur, wenn mein PC eingeschaltet ist. So bekomme ich das Klingeln auch mit, wenn ich Kopfhörer benutze.\n","description":"","tags":["Smarthome","HomeAssistant","ESPHome","MQTT"],"title":"Einbindung meiner Türklingel in Home Assistant","uri":"/posts/smarthome/klingel/"},{"categories":["posts"],"content":"In diesem kurzen Beitrag zeige ich, wie ich einen Zigbee Button verwende, um Automationen in Node-RED zu steuern.\nDer Button und Home Assistant Ich verwende hier den Aqara Wireless Mini Switch von Xiaomi. Das ist ein Zigbee Button, der bei in meinem Home Assistant per deConz eingebunden ist.\nSolche Buttons werden im Home Assistant nicht wie andere Geräte als Entities hinzugefügt. Stattdessen werden beim Drücken des Buttons Events ausgelöst. Diese Events können dann als Trigger für Automationen verwendet werden.\nVerwendung in Node-RED Der Flow in Node-RED besteht aus drei notwendigen Nodes und vier optionalen Nodes. Als erstes benutze ich eine events: all Node, um die Events vom Typ „deconz_event“ abzufangen.\nAls nächstes wird mit einer switch Node in msg.payload.event.id nach der Id des Buttons gefiltert. Die Id leitet sich vom Namen ab, den man in der Phoscon Oberfläche vergeben hat.\nAls drittes wird mit einer weiteren switch Node die Art des Events gefiltert. Der Aqara Button liefert diese vier Events:\n   Event Beschreibung     1002 einfacher Klick   1004 Doppelklick   1001 Halten   1003 Loslassen    Nun kann man seine Flows direkt an die entsprechenden Ausgänge der zweiten switch Node anschliessen. Da ich mir aber nie merken kann, welche Nummer für welchen Klick steht, habe ich noch delay Nodes eingefügt, die auf Rate Limit konfiguriert sind. Dadurch wird der Flow nicht beeinträchtigt, die dienen nur dazu, mir das Programmieren zu erleichtern.\nUnd hier noch der ganze Flow zum importieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193  [ { \"id\": \"9b4d7173.f7538\", \"type\": \"server-events\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"DeconzEvent\", \"server\": \"db71ae1a.4969e\", \"event_type\": \"deconz_event\", \"x\": 110, \"y\": 140, \"wires\": [ [ \"92b4d903.eda7f8\" ] ] }, { \"id\": \"92b4d903.eda7f8\", \"type\": \"switch\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"ID auslesen\", \"property\": \"payload.event.id\", \"propertyType\": \"msg\", \"rules\": [ { \"t\": \"eq\", \"v\": \"smart_switch\", \"vt\": \"str\" } ], \"checkall\": \"true\", \"repair\": false, \"outputs\": 1, \"x\": 310, \"y\": 140, \"wires\": [ [ \"bf4a2cc8.ced0c\" ] ] }, { \"id\": \"bf4a2cc8.ced0c\", \"type\": \"switch\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Event auslesen\", \"property\": \"payload.event.event\", \"propertyType\": \"msg\", \"rules\": [ { \"t\": \"eq\", \"v\": \"1002\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"1004\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"1001\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"1003\", \"vt\": \"str\" } ], \"checkall\": \"true\", \"repair\": false, \"outputs\": 4, \"x\": 560, \"y\": 140, \"wires\": [ [ \"db107f64.bbcf6\" ], [ \"7b49a1f5.e5728\" ], [ \"2f180c9f.1abab4\" ], [ \"cc777d04.e73a4\" ] ] }, { \"id\": \"db107f64.bbcf6\", \"type\": \"delay\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Klick\", \"pauseType\": \"rate\", \"timeout\": \"1\", \"timeoutUnits\": \"seconds\", \"rate\": \"1\", \"nbRateUnits\": \"1\", \"rateUnits\": \"second\", \"randomFirst\": \"1\", \"randomLast\": \"5\", \"randomUnits\": \"seconds\", \"drop\": false, \"x\": 790, \"y\": 120, \"wires\": [ [ \"5ee59413.880bac\", \"288d2bb8.d00f44\" ] ] }, { \"id\": \"7b49a1f5.e5728\", \"type\": \"delay\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Doppel-Klick\", \"pauseType\": \"rate\", \"timeout\": \"1\", \"timeoutUnits\": \"seconds\", \"rate\": \"1\", \"nbRateUnits\": \"1\", \"rateUnits\": \"second\", \"randomFirst\": \"1\", \"randomLast\": \"5\", \"randomUnits\": \"seconds\", \"drop\": false, \"x\": 810, \"y\": 160, \"wires\": [ [ \"c0c2b9f1.29de48\", \"288d2bb8.d00f44\" ] ] }, { \"id\": \"2f180c9f.1abab4\", \"type\": \"delay\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Halten\", \"pauseType\": \"rate\", \"timeout\": \"1\", \"timeoutUnits\": \"seconds\", \"rate\": \"1\", \"nbRateUnits\": \"1\", \"rateUnits\": \"second\", \"randomFirst\": \"1\", \"randomLast\": \"5\", \"randomUnits\": \"seconds\", \"drop\": false, \"x\": 790, \"y\": 200, \"wires\": [ [] ] }, { \"id\": \"cc777d04.e73a4\", \"type\": \"delay\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Loslassen\", \"pauseType\": \"rate\", \"timeout\": \"1\", \"timeoutUnits\": \"seconds\", \"rate\": \"1\", \"nbRateUnits\": \"1\", \"rateUnits\": \"second\", \"randomFirst\": \"1\", \"randomLast\": \"5\", \"randomUnits\": \"seconds\", \"drop\": false, \"x\": 800, \"y\": 240, \"wires\": [ [] ] }, { \"id\": \"db71ae1a.4969e\", \"type\": \"server\", \"z\": \"\", \"name\": \"Home Assistant\", \"legacy\": false, \"addon\": true, \"rejectUnauthorizedCerts\": true, \"ha_boolean\": \"y|yes|true|on|home|open\", \"connectionDelay\": true, \"cacheJson\": true } ]   “english”\n","description":"","tags":["Smarthome","Zigbee","Node-RED","Home Assistant","Xiaomi"],"title":"Zigbee Button mit Node-RED","uri":"/posts/smarthome/zigbeebutton-nodered/"},{"categories":["posts"],"content":"Der Eindruck nach drei Wochen Seit drei Wochen habe ich nun einen Alfawise U50 zu hause. Den Beitrag zum Unboxing und Aufbau könnt Ihr hier nachlesen.\nBisher kann ich sagen, der Drucker funktioniert einfach nur. Ich drucke weiterhin ausschließlich über Octoprint und auch das funktioniert einwandfrei. In diesem Beitrag stelle ich vor, welche Modifikationen bzw. Anbauteile ich bisher hinzugefügt habe und was ich zum Umgang mit dem Drucker gelernt habe.\nAnbauten X-Achsen Abstandshalter Die erste Modifikation, die ich gedruckt habe, ist ein Abstandshalter für den X-Achsen Endstop. Im Auslieferungszustand steht die Düse ausserhalb des Druckbetts, wenn der Endstop betätigt wird. Also habe ich einen Adapter in OpenSCAD konstruiert, der auf die vorhandene Metallfahne gesteckt werden kann und die Düse 4mm weiter innen stoppt. Kamerahalter Das nächste Anbauteil ist ein Kamerahalter für eine Logitech C270 Webcam (Thingiverse). Die Kamera habe ich damit oben auf der Querstrebe montiert, so dass ich das komplette Druckbett im Bild habe. Werkzeughalter Der Werkzeughalter (Thingiverse) ist eigentlich für den Ender 3 gedacht, funktioniert aber genauso gut auch für den U50. Das fertige Teil wird einfach seitlich auf die obere Querstrebe aufgesteckt. Z-Achsen Stabilisator und Filamentführung Die Gewindestange der Z-Achse hat im Auslieferungszustand am oberen Ende keine Halterung oder Führung. Ich habe zwar bisher kein Problem damit gehabt, weil ich noch nicht besonders hoch gedruckt habe, aber auf Thingiverse habe diese Halterung gefunden. Jetzt wird die Gewindestange oben mit einem Kugellager gehalten. Die Filamentführung besteht aus zwei Teilen. Oben habe ich mich für den Arm (Thingiverse) entschieden, den man auf dem letzten Bild sieht. Dabei musste ich das eine Bein mit der Zange kürzen, weil es sich mit der Z-Achsen Halterung in die Quere gekommen ist.\nUnten habe ich eine Führung angebaut, die direkt für den U50 konstruiert wurde und ein Kugellager aufnimmt (Thingiverse). Raspberry Case Wie schon erwähnt drucke ich ausschießlich über Octoprint, das auf einem Raspberry Pi 3 läuft. Also habe ich ein Case gedruckt, dass im Rahmen unterhalb des Druckbetts montiert werden kann (Thingiverse). Halterung für USB-Hub Zu Beginn hatte ich die Webcam und den Drucker direkt am Raspberry Pi angeschlossen. Das hat allerdings dazu geführt, dass das Netzteil immer mal wieder Aussetzer hatte, besonders beim Starten, wenn die Druckerelektronik noch nicht vom eigenen Netzteil versorgt wird. Daher habe ich jetzt einen USB-Hub mit eigenem Netzteil im Einsatz, der zwischen Drucker-Elektronik und Druckbett montiert ist. Die Halterung dafür habe ich in OpenSCAD selbst konstruiert. Kabelmanagement Damit die vielen zusätzlichen Kabel nicht wild herumfliegen und sich mit den beweglichen Teilen des Druckers verheddern habe ich eine handvoll Kabelführungen für Aluprofile (Thingiverse) ausgedruckt. Für die Spannungsversorgung steckt alles in einer Dreifachsteckdose. Die drei Kabel für den Drucker, den Raspberry Pi und den USB-Hub sind mit einem Spiralschlauch zusammengefasst. Der Stecker vom Drucker steckt zusätzlich noch in einer Osram Smart Steckdose, damit ich den Drucker notfalls vom Netz trennen kann. Für die Anbindung in mein Smarthome folgt noch ein eigener Beitrag. Erkenntnisse beim Drucken Die erste wichtige Erkenntnis ist, vor jedem Druck das Leveling zu kontrollieren. Die Druckteile haften an dem mitgelieferten Druckbett bombenfest, so dass ich teilweise einige Kraft aufwenden muss, um die abzulösen. Dadurch wird oft das Leveling verändert.\nDie zweite Erkenntnis ist, immer mit warmem Druckbett zu leveln. Sonst verändert sich durch die Temperatur wieder das Leveling.\n","description":"","tags":["3D-Druck","Prototyping","Raspberry Pi","Octoprint"],"title":"Alfawise U50 – Modifizierungen und Zweiter Eindruck","uri":"/posts/3d-druck/alfawise-u50-zweitereindruck/"},{"categories":["posts"],"content":"Mein erster 3D-Drucker Das Thema 3D-Druck habe ich vor einigen Jahren im Hackerspace kennengelernt. Jetzt habe ich mich endlich dazu durchgerungen, mir einen eigenen Drucker zuzulegen. Nach einem Video von SchimmerMedia habe ich mich für den Alfawise U50 für unter 200€ von Gearbest entschieden.\nDas Unboxing Die Verpackung Der Drucker kommt gut geschützt in Schaumstoff verpackt aus China an.\nUnter dem Schaumstoff liegt als erstes das schon zusammengebaute Unterteil des Druckers sowie ein Karton mit Schrauben und Werkzeug.\nMan braucht zum Zusammenbau fünf(!) unterschiedliche Innensechskantschlüssel. Zum Glück sind alle Größen mitgeliefert. Dazu gibt es noch einen Schaber und einen Seitenschneider um die Druckteile später vom Bett zu lösen und nachzubearbeiten, sowie eine Micro-SD-Karte mit USB-Adapter. Darauf findet man eine alte Version von Cura inklusive einer Konfigurationsdatei, die Aufbauanleitung in digitaler Form und einige fertige 3D Modelle.\nIn der unteren Schaumstoffhälfte findet man die restlichen Anbauteile, die auch bereits teilweise montiert sind.\nDiese Teile gilt es nun nach der Anleitung zusammenzubauen.\nDer Aufbau Der Text der Anleitung ist in einigermaßen verständliches Englisch übersetzt, allerdings sind die Bilder teilweise etwas klein geraten.\nDas erste Teil, das es zu montiert gilt, ist die Kombination aus X-Achsen-Antrieb und Extruder-Antrieb. Das Konstrukt muss an die X-Achsen-Strebe geschraubt werden, wobei die Schraube von hinten in die Bohrung gefummelt werden müssen.\nDas Hotend wird dann einfach nur auf die Schiene gesteckt und die zweite Z-Achsen-Führung wird auf der anderen Seite angeschraubt.\nDer Zahnriemen, der das Hotend bewegt, wird mit gedruckten Klammern fixiert. Mal schauen, wie lange die halten.\nDie senkrechten Alu-Profile werden von unten mit je einer Schraube fixiert. Die rechte Seite wird zusätzlich mit einem T-Profil befestigt.\nDie linke Seite ist wieder etwas fummeliger, weil man hier das Anbauteil mit dem Z-Achsen-Antrieb festschrauben muss.\nHinten wird nun der Y-Achsen-Antrieb montiert. Hier braucht man natürlich zwei unterschiedliche Schraubentypen und die dazu passenden Innensechkantschlüssel.\nDer Riemen für die Y-Achse ist unter dem Druckbett mit Kabelbindern fixiert. Allerdings musste ich eine Seite davon lösen, um den Riemen mit dem Antrieb zu verbinden. Beim erneuten Fixieren ist mir eine der gedruckten Klammern zerbrochen.\nUnd so sieht das ganze vor dem Verkabeln aus.\nDas Verkabeln Alle Komponenten werden mit Steckverbindern verkabeln. Durch die unterschiedliche Größe kann man Servoanschluss und Endschalteranschluss nicht verwechseln. Durch die Steckerform ist auch ein Verpolen im Grunde ausgeschlossen.\nDie einzelnen Kabel sind gut beschriftet und in Kabelschläuchen zusammengefasst.\nDer Anschluss für das Hotend wird per Schraubverbindung gesichert.\nDer Anschluss für den Y-Endschalter ist der einzige, der etwas fummelig anzuschliessen ist.\nSo sieht der Aufbau fertig verkabelt aus. Die Leitungen vom Hotend liegen sehr ungünstig und schleifen wie man sieht am Druckbett. Die habe ich inzwischen mit Kabelbindern nach oben festgemacht.\nDas erste Mal Einschalten Nachdem alles verkabelt war, konnte ich das erste Mal einschalten und da nirgendwo MagicSmoke™ entwichen ist habe ich offensichtlich alles richtig zusammengesteckt. Hier sieht man auch schon das aufgeklebte Druckbett.\nDas Menü bietet Funktionen zur manuellen Ansteuerung aller Achsen, zur Temperaturvorwahl und zum direkten Drucken von der SD-Karte. Die Vorinstallierte Firmware mit der Version 195 hatte das Problem, dass die Geschwindigkeit der Achsen nicht eingestellt werden konnte, weil das Eingabefeld nicht funktioniert hat. In einem französischen 3D-Druck Forum habe ich ein Firmwareupdate auf Version 217 gefunden, in der das Problem behoben ist. Allerdings ließ sich das rar-Archiv unter Linux nicht entpacken, sondern nur unter Windows.\nDer Extruder lässt sich über das Menü nur verfahren, wenn das Hotend aufgeheizt ist. Ob das auch bei externer Steuerung gesperrt ist, habe ich nicht getestet. Das Filament wird vor dem Extruder-Antrieb durch eine Kammer mit Endschalter gefädelt, über den erkannt wird, wenn das Filament zu Ende ist. Nach dem Extruder-Antrieb läuft das Filament durch einen Schlauch zum Hotend. Hier musste ich einen Kabelbinder aufschneiden, weil sich das Filament sonst nicht bis zum Ende einfädeln ließ.\nBeim Anfahren der Home-Position zum Einstellen des Druckbetts ist mir aufgefallen, dass der X-Endschalter zu weit aussen sitzt, sodass das Hotend nicht mehr über dem Druckbett steht. Leider lässt sich der Endschalter nicht verstellen, so dass ich einen provisorischen Abstandshalter an die Schaltefahne geklebt habe. Inzwischen habe ich dafür einen passenden Adapter gedruckt. Dazu kommt noch ein eigener Beitrag.\nMein erster Eindruck Nachdem ich den Drucker bestellt hatte, war ich auf zwei Blogbeträge bei China-Gadets und Drucktipps3D gestoßen, die den U50 ziemlich zerrissen haben. Nun habe ich natürlich nicht soviel Erfahrung mit anderen Druckern aber ich bin mit dem Aufbau und der Qualität bis jetzt durchaus zufrieden.\nGearbest wirbt damit, dass man den Drucker in 20 Minuten zusammenbauen kann, dass kann ich absolut nicht bestätigen. Ich habe mir Zeit gelassen und zwischendurch die Fotos gemacht, so dass ich vom Öffnen des Kartons bis zum Einschalten ungefähr zwei Stunden gebraucht habe. Wie oben schon geschrieben, ist es an einigen Stellen etwas fummelig, aber im Großen und Ganzen lässt der Drucker sich leicht zusammenbauen.\nDen ersten Druck habe ich von meinem Linux-Laptop direkt aus Cura gestartet. Ich verwende die aktuelle Version von Cura, habe die Voreinstellung des Alfawise U20 genommen und nur die Größe des Druckbetts angepasst.\nMittlerweile habe ich den Drucker an einem Raspberry Pi mit Octoprint angeschlossen und drucke von da aus. Ich habe noch keine großen, mehrstündigen Drucke gemacht und bin noch bei der beigelegten Filamentprobe, aber bisher habe ich den Kauf nicht bereut.\n","description":"","tags":["3D-Druck","Prototyping","Raspberry Pi","Octoprint"],"title":"Alfawise U50 – Unboxing und erster Eindruck","uri":"/posts/3d-druck/alfawise-u50-unboxing/"},{"categories":["posts"],"content":"Fenster steuert Heizkörper Wie ich schon in meinem Artikel über mein Smarthomesetup geschrieben habe, sind die Automationen das, was ein Smarthome erst smart macht. Hier beschreibe ich, wie ich den Heizkörper herunterregle, wenn das Fenster geöffnet wird und wieder zurückstelle, wenn das Fenster geschlossen wird.\nUpdate vom 13.01.2021: Mittlerweile lasse ich die Automation nicht mehr über Node-Red laufen, sondern nutze dafür die in Home Assistant eingebauten Automationen.\nBeteiligte Komponenten Das Fenster wird mit einem Xiaomi Aqara Tür-/Fensterkontakt überwacht. Der sendet den Status per Zigbee an den Conbee Stick. Der Conbee ist per Deconz in Home Assistant eingebunden.\nAm Heizkörper ist ein Homematic Heizkörperthermostat montiert. Als Homematiczentrale läuft bei mir ein Raspberry Pi mit Raspberrymatic. Die Thermostate stehen immer auf manuell, weil sie ausschließlich über Home Assistant gesteuert werden.\nDie Absenktemperatur wird über eine input_number Entity eingestellt.\nAutomation in Home Assistant Ich habe für jedes Fenster eine Automation erstellt. Die Automation läuft im Modus Neu Starten, weil ich eine Warten-Aktion verwende und gegebenenfalls noch laufende Instanzen der Automation so abgebrochen werden.\nDer Auslöser ist ganz einfach: Wenn der Fensterkontakt den Zustand zu on wechselt, ist das Fenster geöffnet und die Automation soll starten.\nIch habe hier noch eine Bedingung eingefügt, dass meine Heizungsanlage laufen muss. Wenn im Sommer die Heizung ausgeschaltet ist, soll die Automation nicht am Heizkörper rumdrehen.\nNun folgen die Aktionen, die ausgeführt werden sollen. Als erstes wird eine temporäre Szene erstellt, in der der Zustand des Thermostaten gespeichert wird. Dafür wird der Dienst scene.create aufgerufen und eine scene_id sowie die Entities übergeben.\nAls nächstes wird der Dienst climate.set_temperature aufgerufen. Die Temperatur ist nicht fest eingetragen, sondern wird mit Hilfe eines Templates aus dem input_number-Helfer ausgelesen.\nDanach wird eine Auf Auslöser warten Aktion gestartet, die die Automation pausiert bis der Fensterkontakt wieder geschlossen meldet. Es ist kein Timeout eingetragen, so dass die Automation theoretisch ewig aktiv bleibt.\nWenn das Fenster wieder geschlossen ist, folgt als letzte Aktion das Aktivieren der vorher gespeicherten Szene.\nHier noch die Automation als YAML zum Importieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  alias:Fenster Bürodescription:''trigger:- platform:stateentity_id:binary_sensor.fenster_bueroto:'on'condition:- condition:stateentity_id:binary_sensor.vicare_heizkreisaktivstate:'on'action:- service:scene.createdata:scene_id:buero_snapshotsnapshot_entities:- climate.00201a49a039a4- service:climate.set_temperaturedata:temperature:'{{ states(''input_number.temperatur_niedrig'') }}'entity_id:climate.00201a49a039a4- wait_for_trigger:- platform:stateentity_id:binary_sensor.fenster_bueroto:'off'- scene:scene.buero_snapshotmode:restart  NodeRed (nicht mehr genutzt) Die Automation ist in NodeRed umgesetzt und besteht aus sechs Nodes.\nDie state node „Fenster“ reagiert auf einen Zustandswechsel des Fensterkontakts.\nDie switch node verzweigt je nach Zustand in den oberen oder unteren Weg. Der Binäre Sensor des Fensterkontakts hat den Zustand on, wenn das Fenster geöffnet ist, und off, wenn das Fenster geschlossen ist.\nWenn das Fenster geöffnet wurde, wird als erstes der aktuelle Zustand des Thermostat mit der call service node in einer temporären Szene gespeichert. Im Data Feld muss der Name der Szene und eine Liste der zu speichernden Entities übergeben werden.\n1 2 3 4 5 6  { \"scene_id\": \"thomas_snapshot\", \"snapshot_entities\": [ \"climate.0012999395e750\" ] }   Als nächstes wird der Wert der input_number Entity mit einer current state node ausgelesen.\nZuletzt wird der Thermostat mit einer call service node auf den ausgelesenen Wert gesetzt. Dafür wird im Data Feld {{payload}} als Template verwendet.\n1 2 3  { \"temperature\": {{payload}} }   Beim Schließen des Fensters wird die vorher gespeicherte Szene mit einer weiteren call service node aktiviert. Hier muss nur der Name der Szene im Data Feld übergeben werden.\n1 2 3  { \"entity_id\": \"scene.thomas_snapshot\" }   Solch einen Flow gibt es für jedes Zimmer, in dem ein smarter Thermostat montiert ist. Der Vorteil dieser Methode mit temporärer Szene liegt in der Erweiterbarkeit. Wenn weitere Entities berücksichtigt werden sollen, müssen sie nur an einer Stelle hinzugefügt werden.\nHier noch der komplette Flow zum importieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180  [ { \"id\": \"d302a18c.b4a5c\", \"type\": \"api-call-service\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Temperatur speichern\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"debugenabled\": false, \"service_domain\": \"scene\", \"service\": \"create\", \"entityId\": \"\", \"data\": \"{\\\"scene_id\\\":\\\"thomas_snapshot\\\",\\\"snapshot_entities\\\":[\\\"climate.0012999395e750\\\"]}\", \"dataType\": \"json\", \"mergecontext\": \"\", \"output_location\": \"\", \"output_location_type\": \"none\", \"mustacheAltTags\": false, \"x\": 620, \"y\": 1040, \"wires\": [ [ \"2ba89685.0924aa\" ] ] }, { \"id\": \"68ffd494.662f3c\", \"type\": \"server-state-changed\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Fenster\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"exposeToHomeAssistant\": false, \"haConfig\": [ { \"property\": \"name\", \"value\": \"\" }, { \"property\": \"icon\", \"value\": \"\" } ], \"entityidfilter\": \"binary_sensor.tur_thomas\", \"entityidfiltertype\": \"exact\", \"outputinitially\": false, \"state_type\": \"str\", \"haltifstate\": \"\", \"halt_if_type\": \"str\", \"halt_if_compare\": \"is\", \"outputs\": 1, \"output_only_on_state_change\": true, \"x\": 100, \"y\": 1060, \"wires\": [ [ \"8c0ea6fb.5a5d08\" ] ] }, { \"id\": \"8c0ea6fb.5a5d08\", \"type\": \"switch\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"\", \"property\": \"payload\", \"propertyType\": \"msg\", \"rules\": [ { \"t\": \"eq\", \"v\": \"on\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"off\", \"vt\": \"str\" } ], \"checkall\": \"true\", \"repair\": false, \"outputs\": 2, \"x\": 310, \"y\": 1060, \"wires\": [ [ \"d302a18c.b4a5c\" ], [ \"e5f92e8f.b86af\" ] ] }, { \"id\": \"4acbf5b0.7c7bbc\", \"type\": \"api-call-service\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Temperatur setzen\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"debugenabled\": false, \"service_domain\": \"climate\", \"service\": \"set_temperature\", \"entityId\": \"climate.0012999395e750\", \"data\": \"{\\\"temperature\\\": {{payload}}}\", \"dataType\": \"json\", \"mergecontext\": \"\", \"output_location\": \"\", \"output_location_type\": \"none\", \"mustacheAltTags\": false, \"x\": 1050, \"y\": 1040, \"wires\": [ [] ] }, { \"id\": \"e5f92e8f.b86af\", \"type\": \"api-call-service\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"Temperatur zurücksetzen\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"debugenabled\": false, \"service_domain\": \"scene\", \"service\": \"turn_on\", \"entityId\": \"scene.thomas_snapshot\", \"data\": \"{\\\"entity_id\\\":\\\"scene.thomas_snapshot\\\"}\", \"dataType\": \"json\", \"mergecontext\": \"\", \"output_location\": \"\", \"output_location_type\": \"none\", \"mustacheAltTags\": false, \"x\": 630, \"y\": 1100, \"wires\": [ [] ] }, { \"id\": \"2ba89685.0924aa\", \"type\": \"api-current-state\", \"z\": \"e0fe8a5c.1c4ed8\", \"name\": \"temp_low\", \"server\": \"db71ae1a.4969e\", \"version\": 1, \"outputs\": 1, \"halt_if\": \"\", \"halt_if_type\": \"str\", \"halt_if_compare\": \"is\", \"override_topic\": false, \"entity_id\": \"input_number.temperatur_niedrig\", \"state_type\": \"num\", \"state_location\": \"payload\", \"override_payload\": \"msg\", \"entity_location\": \"data\", \"override_data\": \"msg\", \"blockInputOverrides\": false, \"x\": 840, \"y\": 1040, \"wires\": [ [ \"4acbf5b0.7c7bbc\" ] ] }, { \"id\": \"db71ae1a.4969e\", \"type\": \"server\", \"z\": \"\", \"name\": \"Home Assistant\", \"legacy\": false, \"addon\": true, \"rejectUnauthorizedCerts\": true, \"ha_boolean\": \"y|yes|true|on|home|open\", \"connectionDelay\": true, \"cacheJson\": true } ]   ","description":"","tags":["Smarthome","Node-RED","Home Assistant","Zigbee","Xiaomi","Homematic"],"title":"Fensterautomation","uri":"/posts/smarthome/fensterautomation/"},{"categories":["posts"],"content":"In diesem Beitrag zeige ich, wie ich eine Liste mit Terminen einlese, verarbeite und dann im ICS Format abspeichere.\nHintergrund Die Bremer Stadtreinigung bietet die Müllabfuhrtermine zum Download als ICS Datei und als CSV Datei an. Leider sind dabei für Restmüll und Biomüll jeweils zwei einzelne Termine eingetragen obwohl beides am gleichen Tag abgeholt wird.\nDa ich die Termine ausserdem in mein Smarthome einbinde, um darüber Benachrichtungen zu erhalten, möchte ich sie ausserdem im einem bestimmten Format im Kalender stehen haben. Details zur Einbindung folgen in einem späteren Artikel.\nDas Python-Skript Zu finden ist das fertige Skript hier auf Github. Man braucht mindestens Python 3.6, da ich f-Strings verwende.\nImports Zuerst werden die benötigte Module importiert. ics und arrow können über pip installiert werden, die anderen Module sind in der Standardlibrary enthalten.\n1 2 3 4 5  import csv from ics import Calendar, Event import arrow from dateutil import tz import datetime    csv : Lesen und Schreiben von CSV Dateien ics : Lesen und Schreiben von ICS Dateien arrow : erweiterte Funktionen für Zeitobjekte dateutil.tz : Zeitzonen-Definitionen datetime : Standardfunktionen für Zeitobjekte  Einstellungen Damit mein Skript auch für andere interessant ist, habe ich versucht, verschiedene Möglichkeiten die Termine zu erstellen zu programmieren und parametrierbar zu machen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  ###### Einstellungen ###### # CSV-Datei von der Eno csv_file = r\"Abfuhrtermine für Auf dem Kamp.csv\" # Soll die Art der Abfuhr in den Titel eingetragen werden? True/False descriptive_title = True # Soll für die HomeAssistant Integration ein Offset eingetragen werden? 0..23 offset_hours = 6 # Soll ein ganztägiger Termin erzeugt werden? True/False all_day = True # Workaround für fehlerhafte All Day Events in ics.py aktivieren? True/False ics_workaround = True # Soll der Termin am Tag vor der Abfuhr erzeugt werden? True/False on_day_before = False # Zu welcher Stunde der Termin erzeugt werden, wenn er nicht ganztägig ist? 0..23 event_hour = 18 # Wie lange soll der Termin sein, wenn er nicht ganztägig ist? 0..23 duration_hour = 1 ######   Eingestellt werden kann, ob der Termin ganztägig oder zu einer bestimmten Stunde mit einer einstellbaren Dauer erzeugt werden soll. Dabei kann man den Termin am Vortag der Abfuhr erzeugen oder am richtigen Tag. Man kann die Art der Abfuhr mit in den Titel schreiben lassen oder nur „Müllabfuhr“. Für die Einbindung in Home Assistant kann man einen Offset eintragen lassen.\nHilfsvariablen Bevor es an das Einlesen der CSV Datei geht, erzeuge ich einige Hilfsvariablen.\n1 2 3 4 5 6  # Hilfsvariablen offset_string = f\" !!-{offset_hours:02d}:00\" # globale Variablen vorbelegen d = {} c = Calendar()   Der offset_string wird für die schon angesprochene Home Assistant Einbindung benötigt. Ich benutze hier einen f-String, um den Inhalt der Variablen in den String einzufügen. Der Ausdruck offset_hours:02d sorgt dafür, dass einstellige Zahlen mit führender Null eingefügt werden.\nFür den folgenden Code brauche ich dann noch ein leeres Dictionary d und ein leeres Calendar-Objekt c.\nCSV Datei einlesen Die Einträge in der CSV-Datei sehen folgendermaßen aus:\n1 2 3 4  \"Wochentag\";\"Datum\";\"Abfuhrart\" \"Samstag\";\"04.01.2020\";\"Papier / Gelber Sack\" \"Mittwoch\";\"08.01.2020\";\"Bioabfall\" \"Mittwoch\";\"08.01.2020\";\"Restmüll\"   Die CSV-Datei wird zeilenweise eingelesen und die Einträge vorverarbeitet.\n1 2 3 4 5 6 7 8 9 10 11 12 13  ## Datei öffnen with open(csv_file) as f: # CSV parsen csv_reader = csv.reader(f, delimiter=';', quotechar='\"') for row in csv_reader: if row[0] == 'Wochentag': # Überschrift überspringen continue # Mehrere Abfuhren an einem Tag zusammenfassen if row[1] in d: d[row[1]] =f\"{d[row[1]]} / {row[2]}\" else: d[row[1]] = row[2]   Dem csv.reader muss man dabei das Trennzeichen und den Quotechar mitgeben, damit die Datei korrekt eingelesen wird.\nIn der for-Schleife wird zuerst die Überschrift übersprungen. Als nächstes wird mit if row[1] in d geprüft, ob das Datum schon in meinem Dictionary eingetragen ist. Wenn das der Fall ist, werden die beiden Abfuhrarten über einen f-String zusammengefasst und der Eintrag im Dictionary aktualisiert. Ansonsten wird einfach ein neuer Eintrag zum Dictionary hinzugefügt.\nDamit habe ich nun ein Dictionary mit dem Datums-String als key und der Abfuhrart als value.\nEvents anlegen Im nächsten Schritt wird jetzt über das Dictionary iteriert und das oben angelegte Calendar-Objekt mit Events befüllt. d.items() gibt dabei jeweils Key und Value als Tuple zurück.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Zusammengefasste Termine ins ICS Format umandeln for datum, abfuhr in d.items(): # Event anlegen e = Event() # Titel zusammenbauen e.name = f\"Müllabfuhr{(' ' + abfuhr) if descriptive_title else ''}{offset_string if offset_hours \u003e 0 else ''}\" # Startzeitpunkt zusammenbauen _date = datetime.datetime.strptime(datum, \"%d.%m.%Y\").replace(hour=event_hour, tzinfo=tz.gettz(\"Europe/Berlin\")) begin = arrow.get(_date) if ics_workaround: begin = begin.shift(days = 1) e.begin = begin.shift(days = -1 if on_day_before else 0) # Dauer eintragen bzw. ganztägigen Termin erzeugen e.duration = {\"hours\": duration_hour} if all_day: e.make_all_day() # Art der Abfuhr eintragen e.description = abfuhr # Event eintragen c.events.add(e)   Für den Titel des Events benutze ich wieder einen f-String, um mehrere Strings zusammenzusetzen. Der Ausdruck (' ' + abfuhr) if descriptive_title else '' ist ein sogennater ternärer Operator. Wenn descriptive_title auf True gesetzt ist, wird der Teil vor dem if benutzt, ansonsten der Teil hinter dem else.\nDer Startzeitpunkt wird zunächst als datetime Objekt mit strptime aus dem Key gelesen. Gleichzeitig wird mit .replace die Stunde auf den oben definierten Wert gesetzt und die Zeitzone eingestellt. Das datetime Objekt wird anschließend in arrow Objekt umgewandelt, weil das vom ICS Modul erwartet wird.\nDas ICS Modul hat in der verwendeten Version den Bug, dass bei ganztägigen Terminen die Zeitzone nicht berücksichtigt wird und so der Termin einen Tag zu früh erscheint. Als Workaround schiebe ich daher den Termin mit .shift einen Tag nach vorne, so dass er von ICS am richtigen Tag erzeugt wird. Wenn oben konfiguriert ist, dass der Termin am Tag vor der Abfuhr erzeugt werden soll, wird mit dem gleichen Befehl der Zeitpunkt wieder nach hinten geschoben.\nNun wird die oben eingestellte Dauer in den Termin eingetragen und anschließend gegebenenfalls der Termin in einen ganztägigen Termin umgewandelt.\nZu guter Letzt wird die Abfuhrart in die Terminbeschreibung eingetragen und das Event zum Calender Objekt hinzugefügt.\nICS Datei schreiben Der letzte Schritt ist dann das Calendar Objekt in eine Datei zu schreiben.\n1 2 3  # Kalenderdatei schreiben with open(\"abfuhr.ics\", \"w\") as f: f.writelines(c)   Die entstandene Datei kann man nun zum Beispiel in Google importieren.\n","description":"","tags":["Python","Home Assistant","Datatransformation","ICS"],"title":"Termine mit Python aufbereiten","uri":"/posts/programmieren/termine_aufbereiten/"},{"categories":["posts"],"content":"Dieser Blog wird mit Hugo erstellt. In diesem Beitrag erzähle ich was es damit auf sich hat und wie ich dazu gekommen bin.\nWas ist Hugo? Hugo ist nach eigener Aussage das weltweit schnellste Framework für die Erstellung statischer Webseiten. Hugo ist in Go programmiert und verfügbar für alle gängigen Betriebssysteme.\nDie Beiträge werden in Markdown geschrieben und dann „kompiliert“ um die HTML Seiten zu erstellen. Das Aussehen wird dabei über Themes festgelegt.\nDamit ist der Workflow mit dem von $\\LaTeX$ vergleichbar.\nWarum Hugo? An den meisten Content-Management-Systemen wie Wordpress, Drupal, Typo3, etc. hat mich immer gestört, dass man dafür ein mehr oder weniger mächtiges Backend aufsetzen muss. Man braucht immer PHP oder Python und eine Datenbank, auch wenn man eigentlich nur einen einfachen Blog schreiben möchte.\nIm Self Hosted Podcast habe ich dann von Hugo gehört.\nWie geht es los? Vorbereitung Für Hugo gibt es diverse Installationsmethoden. Auf meinem Windowsrechner habe ich das Programm als ZIP heruntergeladen, unter Linux habe ich es mit Snap installiert. Details sind auf der Hugo Webseite zu finden.\nEs ist nicht zwingend erforderlich, aber es erleichtert einige Vorgänge, wenn man Git benutzt. Daher gehe ich in diesem Artikel davon aus, dass ihr Git installiert habt und über einen Github Account verfügt.\nSeite anlegen Das Grundgerüst der Seite legt man mit dem folgenden Kommando auf der Konsole an:\nhugo new site meinblog Hugo erzeugt damit ein Unterverzeichnis mit dem Namen meinblog und diesem Inhalt:\narchetypes/ config.toml content/ data/ layouts/ static/ themes/ Als nächstes sollte man sich ein Theme aus der Hugo Theme Liste aussuchen. Ich habe einige ausprobiert und mich schließlich für das MemE Theme entschieden. Die Installation funktioniert am einfachsten mit Git wie im README beschrieben. Die config.toml muss man an seine eigenen Bedürfnisse anpassen. Dazu folgt noch ein weiterer Artikel.\nArtikel anlegen Artikel legt man im Verzeichnis content als .md-Dateien an. Dabei kann man optional Unterordner als Kategorien anlegen. Man kann die Datei manuell anlegen oder diesen Hugo-Befehl dafür benutzen:\nhugo new posts/my-first-post.md Der Vorteil gegenüber dem manuellen Anlegen ist, dass gleich ein Frontmatter mit angelegt wird. Das ist der Konfigurationsbereich des Artikels, wo Aussehen und Verhalten angepasst werden kann. Auch dazu folgt noch ein weiterer Artikel.\nIn diesem Zustand kann man jetzt schon den integrierten Server starten und die (leere) Seite anzeigen:\nhugo server -D Die Option -D an dieser Stelle ist wichtig, damit auch Artikel die als Draft (also Entwurf) gekennzeichnet sind erzeugt und angezeigt werden.\nJetzt kann man seine Artikel schreiben. Wenn der Server im Hintergrund läuft, wird die Seite automatisch neu erzeugt und im Browser aktualisiert, sobald man eine Datei ändert und speichert.\nSeite veröffentlichen Wenn man fertig mit seinen Artikeln ist ruft man hugo ohne weitere Optionen auf. Damit wird im Unterverzeichnis public die fertige Webseite mit allen nötigen Dateien erzeugt. Dieses Verzeichnis kann jetzt auf jedem Webserver gehostet werden. Der Workflow für das Hosten als github.io Seite wird auf der Hugo-Webseite gezeigt.\n","description":"","tags":["Hugo","Website"],"title":"Website mit Hugo erstellen – Einstieg","uri":"/posts/allgemein/website-mit-hugo/"},{"categories":["posts"],"content":"In diesem Beitrag zeige ich die Schritte, um meinen Umweltsensor mit Button nachzubauen. Der Sensor misst Temperatur, Luftfeuchtigkeit und Luftdruck und hat einen Button um beliebige Aktionen auszulösen.\nVorbereitung Was ist ESPHome? Laut der Selbstbeschreibung auf esphome.io ist ESPHome ein System, um ESP8266 bzw. ESP32 Mikrocontroller mit Hilfe von einfachen Konfigurationsdateien zu programmieren.\nESPHome ist in Python geschrieben und lässt sich auch ohne Home Assistant einfach über pip install esphome oder mit docker pull esphome/esphome installieren. Ich benutze ESPHome als Home Assistant Addon, da bekommt man noch eine Weboberfläche zur Administration dazu.\nBenötigte Hardware  ESP8266 Mikrocontroller - z.B. Wemos D1 mini BME280 Sensor - mit I²C Breakoutboard Drucktaster  Das Gehäuse ist aus 3mm MDF gelasert. Ein Generator für solche Gehäuse ist zum Beispiel boxes.py.\nSensor und Button anschließen Der BME280 wird per I²C angeschlossen, dafür brauchen wir die folgenden Pins:\n 5V → VIN G → GND D4 → SDA D5 → SCL  Den Pin für den Button kann man frei wählen, allerdings gibt es einige Pins, die spezielle Funktionen beim Booten auslösen. Ich habe hier Pin D3 verwendet, der zweite Pin des Buttons wird mit GND verbunden.\nIch habe das ganze mit Sockeln auf einer Lochrasterplatine aufgebaut, um die Bauteile leicht wieder auseinanderbauen zu können.\nESPHome Projekt in Home Assistant Projekt anlegen Auf der Weboberfläche klickt man auf den freundlichen roten Button mit dem Plus, um den Wizard für neue Projekte aufzurufen.\nAls erstes vergibt man einen Namen.\nZweiter Schritt ist die Auswahl des Mikrocontrollers. Ich benutze für die meisten Projekte den Wemos D1 mini.\nAls letztes folgt die Angabe der WLan-Daten und des Passworts für das Over-the-air Update. Ich benutze hier die von Home Assistant bekannte !secret Notation. Details dazu weiter unten.\nNun ist der Wizard abgeschlossen und zeigt uns die nächsten Schritte, um den Mikrocontroller zu programmieren.\nNachdem man den Wizard mit Submit geschlossen hat, wird man noch auf die Schnittstellenauswahl in der oberen Ecke hingewiesen.\nDateiorganisation und !secrets In Home Assistant liegen die Projektdateien im Verzeichnis /config/esphome. Das Beispiel oben hat eine umweltsensor.yaml erzeugt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  esphome:name:umweltsensorplatform:ESP8266board:d1_miniwifi:ssid:\"!secret wifi-ssid\"password:\"!secret wifi-password\"# Enable fallback hotspot (captive portal) in case wifi connection failsap:ssid:\"Umweltsensor Fallback Hotspot\"password:\"lg2kCzecpat7\"captive_portal:# Enable logginglogger:# Enable Home Assistant APIapi:password:\"!secret esphome-password\"ota:password:\"!secret esphome-password\"  Im gleichen Verzeichnis habe ich eine secrets.yaml angelegt. Die Einträge darin können in anderen .yaml Dateien mit !secret importiert werden. Das hat den Vorteil, dass man die Projektdatei mit anderen teilen kann, so wie ich hier, ohne dass man seine Zugangsdaten weitergibt.\nDas erste Mal Flashen Zum ersten Flashen muss der Mikrocontroller per USB mit dem Rechner verdunden werden, auf dem ESPHome läuft. In meinem Fall ist das der Raspberry Pi auf dem Home Assistant installiert ist.\nMeistens wird der Port des Mikrocontrollers nicht sofort angezeigt, wenn man das USB Kabel anschließt. Das hängt mit dem Docker System zusammen auf dem Home Assistant basiert. Der Workaround ist das Addon neuzustarten, nachdem der Mikrocontroller angeschlossen ist.\nWenn nichts anderes angeschlossen ist, wird wahrscheinlich /dev/ttyUSB0 angezeigt, in meinem Fall ist der Mikrocontroller an /dev/ttyUSB1.\nDamit die Zugangsdaten korrekt importiert werden, müssen wir noch die erzeugte .yaml Datei bearbeiten und die Anführungszeichen bei allen Einträgen mit !secret entfernen. Dazu klickt man auf EDIT unter dem entsprechenden Eintrag.\nAls letztes klickt man auf UPLOAD um das Flashen zu starten.\nWenn alles korrekt funktioniert hat, sollte nun aus der .yaml Datei der Arduino-Code generiert werden. Dabei werden im Hintergrund alle benötigten Bibliotheken heruntergeladen, der Code kompiliert und der Upload gestartet.\nIn der folgenden Logging-Ausgabe kann man kontrollieren, ob man die WLAN Daten korrekt eingeben hat.\nAb jetzt kann man den Mikrocontroller vom Raspberry Pi trennen und übers WLAN programmieren. Dafür stellt man die Schnittstelle oben auf Over-the-Air um.\nSensor und Button konfigurieren Damit der Sensor angesprochen werden kann wird als erstes die I²C Komponente geladen. Die Option scan: True sorgt dafür, dass bei jedem Boot der Bus nach Geräten gescannt wird.\n1 2 3 4  i2c:sda:4scl:5scan:True  Da der BME280 drei Größen misst, müssen entsprechend die drei Optionen temperature, pressure und humidity konfiguriert werden.\nUnter filters: ist beim Temperatursensor ein statischer Offset von -7 Grad eingestellt, den ich im Vergleich mit einem zweiten Sensor ermittelt habe. Ebenso ist bei der Luftfeuchtigkeit ein statischer Offset von +10 Prozent eingestellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  sensor:- platform:bme280temperature:name:\"Thomas Zimmer Temperatur\"oversampling:16xfilters:- offset:-7.0pressure:name:\"Thomas Zimmer Luftdruck\"humidity:name:\"Thomas Zimmer Feuchtigkeit\"filters:- offset:+10.0address:0x76update_interval:60s  Der Button wird als Binärsensor konfiguriert. Da der Button mit GND verbunden ist, muss hier der interne Pullup-Widerstand aktiviert werden und mit inverted: True der Zustand invertiert werden. Damit liefert der Sensor on, wenn der Button gedrückt wird.\n1 2 3 4 5 6 7 8 9  binary_sensor:- platform:gpiopin:number:D3mode:INPUT_PULLUPinverted:Truename:\"Thomas Zimmer Button\"filters:- delayed_on:10ms  Mit Home Assistant verbinden Nachdem das vollständige Programm auf den Mikrocontroller geladen ist, müssen die Sensoren noch in Home Assistant einbunden werden. Die Einrichtung erfolgt über die Integrationsseite in den Home Assistant Einstellungen.\nAls Hostadresse gibt man den Namen des Projekts ein, in diesem Fall umweltsensor.local.\nNach der API Passwort Abfrage werden automatisch die Entities für die konfigurierten Sensoren zu Home Assitant hinzugefügt.\n","description":"","tags":["Smarthome","Home Assistant","ESPHome","ESP8266"],"title":"Umweltsensor mit ESPHome in Home Assistant","uri":"/posts/smarthome/esphome-sensor/"},{"categories":["posts"],"content":"Hier möchte ich einen kurzen Überblick über mein Smarthome Setup geben. Auf Details werde ich dann später in weiteren Beiträgen eingehen.\nZentrale Als Smarthome-Zentrale habe ich Home Assistant auf einem Raspberry Pi 3B+ laufen. Ich benutze die native Version mit HassOS und boote direkt von einer SSD Festplatte. Per USB angeschlossen ist hier ein Conbee Stick für die Zigbee-Anbindung. Daneben läuft ein Raspberry Pi 1 mit RaspberryMatic, um meine Homematic Komponenten anzubinden.\nMein Router ist eine FritzBox 7590 unterstützt durch einen FritzRepeater 1750E zur Anbindung von WLAN Komponenten.\nSowohl die Fritzbox als auch der Haupt-Raspberry sind durch eine unterbrechungsfreie Stromversorgung gepuffert, da hier gerne mal die Sicherung fliegt, wenn ich meine Steckdosenleiste einschalte.\nHardwareliste  Raspberry Pi 3B+ mit 2,4A Netzteil. Intenso Portable SSD mit 128GB. Zusätzliche Stromversorgung mit 2,4A Netzteil und USB Y-Kabel. Conbee Stick von Dresden Elektronik Unterbrechungsfreie Stromversorgung APC BX700U-GR Raspberry Pi 1 mit HM-MOD-RPI-PCB von ELV  Software Ich habe mich beim Umzug auf die SSD Festplatte gegen ein Setup mit z.B. Rasbian entschieden, sondern wieder die native Installation benutzt, weil ich so kein weiteres Betriebssystem administrieren muss, sondern alles aus der Home Assistant Oberfläche verwalten kann. Neben dem Home Assistant laufen allerdings noch einige Addons auf dem Raspberry:\n ADB Bridge für die Android TV Anbindung APC USB Daemon für die Anbindung der USV Duck DNS für Fernzugriff per SSL aus dem Internet ESPhome für selbstgebaute Komponenten File Editor zum Bearbeiten der Konfiguration im Browser Hass.io Google Drive Backup für die automatische Sicherung des Systems MariaDB als Alternative für die SQLite History Datenbank Mosquitto broker für MQTT Node-RED für die Automatisierung Samba-Share für Datenzugriff von anderen Rechnern TasmoAdmin für die Verwaltung der Tasmota Komponenten Terminal \u0026 SSH für Low Level Zugriff auf das System chrony als lokaler NTP Server deCONZ für die Verwaltung der Zigbee Komponenten  Zusätzlich ist natürlich auch noch HACS (Home Assistant Community Store) installiert für Custom Components, Lovelace Plugins und Themes.\nKomponenten Der Vorteil von Home Assistant ist, dass sich Komponenten von den verschiedensten Herstellern und mit den unterschiedlichsten Technologien integrieren lassen. Dementsprechend sind in der Wohnung diverse Sensoren und Aktoren verteilt.\nSensoren In fast jedem Raum werden Temperatur, Luftfeuchtigkeit und Luftdruck erfasst. Dazu kommen zum einen die Aqara WSDCGQ11LM Multisensoren über Zigbee zum Einsatz, zum anderen habe ich ESP8266 mit BME280 Sensoren per ESPhome angebunden.\nFenster und Türen werden mit Aqara und Homematic Tür-/Fensterkontakten überwacht. Als Bewegungsmelder dient ein IKEA Tradfri über Zigbee.\nIm Keller überwacht ein Sonoff POW die Leistungsaufnahme der Waschmaschine.\nLicht Die Deckenbeleuchtung ist bisher noch nicht smart in meiner Wohnung, allerdings bleibt die sowieso meist aus, weil das Licht von Dekoleuchten oder indireker Beleuchtung kommt.\nDie Dekoleuchten haben fast alle ein klassisches Leuchtmittel und sind in smarte Zwischensteckdosen eingesteckt. Die meisten sind von Teckin oder Sonoff und umgeflasht auf Tasmota. Eine weitere kommt von Osram und ist über Zigbee angebunden.\nDaneben gibt es einige direkt angebundene Leuchtmittel. Eine Birne von Eufy, angebunden über deren Cloud Dienst, ein LED-Strip von Osram über Zigbee und zwei selbstgebaute LED-Leuchten, angebunden über ESPhome.\nHeizung Unsere Viessmann Heizungsanlage ist über die Cloud angebunden, an den Heizkörpern sind Homematic Thermostate montiert.\nRollladen Für die Steuerung der elektrischen Rollladen habe ich Shelly 2.5 Unterputzaktoren eingebaut und lokal per MQTT angebunden.\nInteraktion Die meisten Komponenten lassen sich per Alexa Spracheingabe steuern, alle Komponenten sind über die Weboberfläche bzw. Companion App auf dem Handy steuerbar. Für einige Aktionen gibt es zusätzlich physikalische Taster. Neben dem Aqara WXKG11LM Zigbee Taster kommt auch hier wieder ein selbst gebauter Button via ESPhome zum Einsatz.\nAutomation Die Automationen sind natürlich das, was das Smarthome erst smart macht. Hier wieder nur eine kurze Übersicht:\nIm Wohnzimmer wird das Licht abhängig vom Fernseher an- und ausgeschaltet. Die Heizkörper sind mit den Fenstern verknüpft und regeln zusätzlich nach Tageszeit rauf oder runter.\nWenn ich ins Bett gehe, wird der Rechner und das NAS heruntergefahren, die Rollladen geschlossen und der Heizkörper heruntergeregelt.\nEs gibt Benachrichtigungen, wenn die Waschmaschine fertig ist, wenn es an der Tür klingelt und wenn der Müll rausgestellt muss.\n Das soll als kurzer Überblick über mein Setup genügen. Wie bereits oben geschrieben, folgen bald weitere Artikel mit Details zu einzelnen Themen.\n","description":"","tags":["Smarthome","Home Assistant","Zigbee","Homematic","Raspberry Pi"],"title":"Mein Smarthome Setup","uri":"/posts/smarthome/mein_setup/"},{"categories":["posts"],"content":"Warum ein eigener Blog? Frei nach Alf halte ich mich an das Motto: „Wenn Du sowieso nichts zu sagen hast, dann schreibt halt einen Blog.“\nOb ich wirklich nichts zu sagen habe, wird sich zeigen.\nWorüber schreibe ich? Ich schreibe über Smart Home, Python und dergleichen mehr.\n","description":"","tags":null,"title":"Und jetzt bloggt er auch noch…","uri":"/posts/allgemein/my-first-post/"},{"categories":["about"],"content":"Impressum Angaben gemäß § 5 TMG Thomas Helmke\nAuf dem Kamp 31\n28217 Bremen\nKontakt Telefon: 04213802659\nE-Mail: thomas.helmke@gmx.de\nVerantwortlich für den Inhalt nach § 55 Abs. 2 RStV Thomas Helmke\nAuf dem Kamp 31\n28217 Bremen\nHaftung für Inhalte Als Diensteanbieter sind wir gemäß § 7 Abs.1 TMG für eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach §§ 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen.\nVerpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unberührt. Eine diesbezügliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung möglich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen.\nHaftung für Links Unser Angebot enthält Links zu externen Websites Dritter, auf deren Inhalte wir keinen Einfluss haben. Deshalb können wir für diese fremden Inhalte auch keine Gewähr übernehmen. Für die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf mögliche Rechtsverstöße überprüft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar.\nEine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Links umgehend entfernen.\nUrheberrecht Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielfältigung, Bearbeitung, Verbreitung und jede Art der Verwertung außerhalb der Grenzen des Urheberrechtes bedürfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur für den privaten, nicht kommerziellen Gebrauch gestattet.\nSoweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitten wir um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Inhalte umgehend entfernen.\nQuelle:\ne-recht24.de\n","description":"","tags":null,"title":"Impressum","uri":"/about/"}]
